

function (_ENV)
local string, math, print, type, pairs = nil, nil, nil, nil, nil;
local _module = _obj({exports=_obj({})}); local exports, module = _module.exports, _module;

local Session, debug, MemoryStore, signature, Cookie, Store, utils, uid, parse, crc32, env, warning, session, hash = Session, debug, MemoryStore, signature, Cookie, Store, utils, uid, parse, crc32, env, warning, session, hash;
session = (function (this, options)
local session = _debug.getinfo(1, 'f').func;
local options, key, store, cookie, trustProxy, storeReady, session = options, key, store, cookie, trustProxy, storeReady, session;
options = options or _obj({
  });
key = (options).key or ("connect.sid");
store = (options).store or _new(MemoryStore);
cookie = (options).cookie or _obj({
  });
trustProxy = (options).proxy;
storeReady = (true);
if _truthy((("production") == env) and _instanceof(store, MemoryStore)) then
if console:warn(warning) then end;
end
(store).generate = (function (this, req)
(req).sessionID = uid(global, (24));
(req).session = _new(Session, req);
((req).session).cookie = _new(Cookie, cookie);
end);
if store:on(("disconnect"), (function (this)
storeReady = (false);
end)) then end;
if store:on(("connect"), (function (this)
storeReady = (true);
end)) then end;
if true then return (function () session = (function (this, req, res, next)
local session = _debug.getinfo(1, 'f').func;
local secret, originalHash, originalId, rawCookie, unsignedCookie, __K__end, generate, pause = secret, originalHash, originalId, rawCookie, unsignedCookie, __K__end, generate, pause;
generate = (function (this)
local generate = _debug.getinfo(1, 'f').func;
if store:generate(req) then end;
end);
if _truthy((req).session) then
if true then return next(global); end;
end
if (not _truthy(storeReady)) then
if true then return _seq({debug(global, ("store is disconnected")), next(global)}); end;
end
if ((0) ~= (req).originalUrl:indexOf((cookie).path or ("/"))) then
if true then return next(global); end;
end
secret = (options).secret or (req).secret;
if (not _truthy(secret)) then
_error(_new(Error, ("`secret` option required for sessions")))
end
originalHash = nil;
originalId = nil;
(req).sessionStore = store;
rawCookie = ((req).cookies)[key];
unsignedCookie = ((req).signedCookies)[key];
if _truthy((not _truthy(unsignedCookie)) and rawCookie) then
unsignedCookie = utils:parseSignedCookie(rawCookie, secret);
end
if res:on(("header"), (function (this)
local cookie, proto, tls, isNew, val = cookie, proto, tls, isNew, val;
if (not _truthy((req).session)) then
if true then return; end;
end
cookie = ((req).session).cookie;
proto = (((req).headers)[("x-forwarded-proto")] or (""):split((",")))[(0)]:toLowerCase():trim();
tls = ((req).connection).encrypted or trustProxy and (("https") == proto);
isNew = (unsignedCookie ~= (req).sessionID);
if _truthy((cookie).secure and (not _truthy(tls))) then
if true then return debug(global, ("not secured")); end;
end
if _truthy((not _truthy(isNew)) and (cookie).hasLongExpires) then
if true then return debug(global, ("already set cookie")); end;
end
if _truthy(((null) == (cookie).expires)) then
if (not _truthy(isNew)) then
if true then return debug(global, ("already set browser-session cookie")); end;
end
else
if _truthy((originalHash == hash(global, req.session)) and (originalId == ((req).session).id)) then
if true then return debug(global, ("unmodified session")); end;
end
end
val = (("s:") + signature:sign(req.sessionID, secret));
val = cookie:serialize(key, val);
if debug(global, ("set-cookie %s"), val) then end;
if res:setHeader(("Set-Cookie"), val) then end;
end)) then end;
_K_end = (res)["end"];
(res)["end"] = (function (this, data, encoding)
(res)["end"] = _K_end;
if (not _truthy((req).session)) then
if true then return (function () local base, prop = res, "end"; return base[prop](base, data, encoding); end)(); end;
end
if debug(global, ("saving")) then end;
if (req).session:resetMaxAge() then end;
if (req).session:save((function (this, err)
if _truthy(err) then
if (function () local base, prop = console, "error"; return base[prop](base, err.stack); end)() then end;
end
if debug(global, ("saved")) then end;
if (function () local base, prop = res, "end"; return base[prop](base, data, encoding); end)() then end;
end)) then end;
end);
(req).sessionID = unsignedCookie;
if (not _truthy((req).sessionID)) then
if debug(global, ("no SID sent, generating session")) then end;
if generate(global) then end;
if next(global) then end;
if true then return; end;
end
pause = utils:pause(req);
if debug(global, ("fetching %s"), req.sessionID) then end;
if store:get(req.sessionID, (function (this, err, sess)
local ____next = ____next;
__next = next;
next = (function (this, err)
if __next(global, err) then end;
if pause:resume() then end;
end);
if _truthy(err) then
if debug(global, ("error %j"), err) then end;
if _truthy((("ENOENT") == (err).code)) then
if generate(global) then end;
if next(global) then end;
else
if next(global, err) then end;
end
else
if (not _truthy(sess)) then
if debug(global, ("no session found")) then end;
if generate(global) then end;
if next(global) then end;
else
if debug(global, ("session found")) then end;
if store:createSession(req, sess) then end;
originalId = (req).sessionID;
originalHash = hash(global, sess);
if next(global) then end;
end
end
end)) then end;
end); return session; end)(); end;
end);
hash = (function (this, sess)
local hash = _debug.getinfo(1, 'f').func;
if true then return crc32:signed(JSON:stringify(sess, (function (this, key, val)
if (("cookie") ~= key) then
if true then return val; end;
end
end))); end;
end);
Session = require(global, ("./session/session"));
debug = require(global, ("debug"))(global, ("connect:session"));
MemoryStore = require(global, ("./session/memory"));
signature = require(global, ("cookie-signature"));
Cookie = require(global, ("./session/cookie"));
Store = require(global, ("./session/store"));
utils = require(global, ("./../utils"));
uid = require(global, ("uid2"));
parse = (utils).parseUrl;
crc32 = require(global, ("buffer-crc32"));
env = ((process).env).NODE_ENV;
exports = (function () local _r = session; (module).exports = _r; return _r; end)();
(exports).Store = Store;
(exports).Cookie = Cookie;
(exports).Session = Session;
(exports).MemoryStore = MemoryStore;
warning = ((("Warning: connection.session() MemoryStore is not\n")
  + ("designed for a production environment, as it will leak\n"))
  + ("memory, and will not scale past a single process."));

return _module.exports;
end