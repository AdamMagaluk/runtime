

function (_ENV)
local string, math, print, type, pairs = nil, nil, nil, nil, nil;
local _module = _obj({exports=_obj({})}); local exports, module = _module.exports, _module;

local utils, Cache, fresh, staticCache, respondFromCache, mustRevalidate, cacheKey = utils, Cache, fresh, staticCache, respondFromCache, mustRevalidate, cacheKey;
respondFromCache = (function (this, req, res, cacheEntry)
local respondFromCache = _debug.getinfo(1, 'f').func;
local status, headers, content, write = status, headers, content, write;
status = (cacheEntry)[(0)];
headers = utils:merge(_obj({
  }), cacheEntry[(1)]);
content = cacheEntry:slice((2));
(headers).age = (((_new(Date) - _new(Date, (headers).date))) / (1000)) or (0);
repeat
local _0 = ("HEAD"); local _1 = ("GET"); local _2;
local _r = (req).method;
if _r == _0 then
if res:writeHead(status, headers) then end;
if (function () local base, prop = res, "end"; return base[prop](base); end)() then end;
_c = _break; break;
end
if _r == _1 then
if _truthy(utils:conditionalGET(req) and fresh(global, req.headers, headers)) then
(headers)[("content-length")] = (0);
if res:writeHead((304), headers) then end;
if (function () local base, prop = res, "end"; return base[prop](base); end)() then end;
else
write = (function (this)
local write = _debug.getinfo(1, 'f').func;
while _truthy((content).length) do

if ((false) == res:write(content:shift())) then
if res:once(("drain"), write) then end;
if true then return; end;
end

end
if (function () local base, prop = res, "end"; return base[prop](base); end)() then end;
end);
if res:writeHead(status, headers) then end;
if write(global) then end;
end
_c = _break; break;
end
if res:writeHead((500), ("")) then end;
if (function () local base, prop = res, "end"; return base[prop](base); end)() then end;
until true
end);
mustRevalidate = (function (this, req, cacheEntry)
local mustRevalidate = _debug.getinfo(1, 'f').func;
local cacheHeaders, reqCC, cacheCC, cacheAge = cacheHeaders, reqCC, cacheCC, cacheAge;
cacheHeaders = (cacheEntry)[(1)];
reqCC = utils:parseCacheControl(((req).headers)[("cache-control")] or (""));
cacheCC = utils:parseCacheControl((cacheHeaders)[("cache-control")] or (""));
cacheAge = (((_new(Date) - _new(Date, (cacheHeaders).date))) / (1000)) or (0);
if _truthy((cacheCC)[("no-cache")] or (cacheCC)[("must-revalidate")] or (cacheCC)[("proxy-revalidate")]) then
if true then return (true); end;
end
if _truthy((reqCC)[("no-cache")]) then
if true then return (true); end;
end
if ((null) ~= (reqCC)[("max-age")]) then
if true then return ((reqCC)[("max-age")] < cacheAge); end;
end
if ((null) ~= (cacheCC)[("max-age")]) then
if true then return ((cacheCC)[("max-age")] < cacheAge); end;
end
if true then return (false); end;
end);
cacheKey = (function (this, req)
local cacheKey = _debug.getinfo(1, 'f').func;
if true then return (utils:parseUrl(req)).path; end;
end);
utils = require(global, ("../utils"));
Cache = require(global, ("../cache"));
fresh = require(global, ("fresh"));
(module).exports = (function () staticCache = (function (this, options)
local staticCache = _debug.getinfo(1, 'f').func;
local options, cache, maxlen, staticCache = options, cache, maxlen, staticCache;
options = options or _obj({
  });
cache = _new(Cache, (options).maxObjects or (128));
maxlen = (options).maxLength or ((1024) * (256));
if console:warn(("connect.staticCache() is deprecated and will be removed in 3.0")) then end;
if console:warn(("use varnish or similar reverse proxy caches.")) then end;
if true then return (function () staticCache = (function (this, req, res, next)
local staticCache = _debug.getinfo(1, 'f').func;
local key, ranges, hasCookies, hit = key, ranges, hasCookies, hit;
key = cacheKey(global, req);
ranges = ((req).headers).range;
hasCookies = ((req).headers).cookie;
hit = cache:get(key);
if req:on(("static"), (function (this, stream)
local headers, cc, contentLength, hit, arr = headers, cc, contentLength, hit, arr;
headers = (res)._headers;
cc = utils:parseCacheControl((headers)[("cache-control")] or (""));
contentLength = (headers)[("content-length")];
hit = nil;
if _truthy((headers)[("set-cookie")]) then
if true then return (function () local _r = (true); hasCookies = _r; return _r; end)(); end;
end
if _truthy(hasCookies) then
if true then return; end;
end
if _truthy((not _truthy(contentLength)) or (contentLength > maxlen)) then
if true then return; end;
end
if _truthy((headers)[("content-range")]) then
if true then return; end;
end
if _truthy((cc)[("no-cache")] or (cc)[("no-store")] or (cc)[("private")] or (cc)[("must-revalidate")]) then
if true then return; end;
end
if _truthy((function () local _r = cache:get(key); hit = _r; return _r; end)()) then
if _truthy(((headers).etag == ((hit)[(0)]).etag)) then
((hit)[(0)]).date = _new(Date);
if true then return; end;
else
if cache:remove(key) then end;
end
end
if _truthy(((null) == stream)) then
if true then return; end;
end
arr = _arr({});
if stream:on(("data"), (function (this, chunk)
if arr:push(chunk) then end;
end)) then end;
if stream:on(("end"), (function (this)
local cacheEntry = cacheEntry;
cacheEntry = cache:add(key);
(headers)[("x-cache")] = nil;
if cacheEntry:push((200)) then end;
if cacheEntry:push(headers) then end;
if (cacheEntry).push:apply(cacheEntry, arr) then end;
end)) then end;
end)) then end;
if _truthy(((req).method == ("GET")) or ((req).method == ("HEAD"))) then
if _truthy(ranges) then
if next(global) then end;
else
if _truthy((not _truthy(hasCookies)) and hit and (not _truthy(mustRevalidate(global, req, hit)))) then
if res:setHeader(("X-Cache"), ("HIT")) then end;
if respondFromCache(global, req, res, hit) then end;
else
if res:setHeader(("X-Cache"), ("MISS")) then end;
if next(global) then end;
end
end
else
if next(global) then end;
end
end); return staticCache; end)(); end;
end); return staticCache; end)();

return _module.exports;
end