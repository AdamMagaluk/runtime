-- Copyright Joyent, Inc. and other Node contributors.
--
-- Permission is hereby granted, free of charge, to any person obtaining a
-- copy of this software and associated documentation files (the
-- "Software"), to deal in the Software without restriction, including
-- without limitation the rights to use, copy, modify, merge, publish,
-- distribute, sublicense, and/or sell copies of the Software, and to permit
-- persons to whom the Software is furnished to do so, subject to the
-- following conditions:
--
-- The above copyright notice and this permission notice shall be included
-- in all copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-- OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-- MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
-- NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
-- DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
-- OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
-- USE OR OTHER DEALINGS IN THE SOFTWARE.


-- a transform stream is a readable/writable stream where you do
-- something with the data.  Sometimes it's called a "filter",
-- but that's not a great name for it, since that implies a thing where
-- some bits pass through, and others are simply ignored.  (That would
-- be a valid example of a transform, of course.)
--
-- While the output is causally related to the input, it's not a
-- necessarily symmetric or synchronous transformation.  For example,
-- a zlib stream might take multiple plain-text writes(), and then
-- emit a single compressed chunk some time in the future.
--
-- Here's how this works:
--
-- The Transform stream has all the aspects of the readable and writable
-- stream classes.  When you write(chunk), that calls _write(chunk,cb)
-- internally, and returns false if there's a lot of pending writes
-- buffered up.  When you call read(), that calls _read(n) until
-- there's enough pending readable data buffered up.
--
-- In a transform stream, the written data is placed in a buffer.  When
-- _read(n) is called, it transforms the queued up data, calling the
-- buffered _write cb's as it consumes chunks.  If consuming a single
-- written chunk would result in multiple output chunks, then the first
-- outputted bit calls the readcb, and subsequent chunks just go into
-- the read buffer, and will cause it to emit 'readable' if necessary.
--
-- This way, back-pressure is actually determined by the reading side,
-- since _read has to be called to start processing a new chunk.  However,
-- a pathological inflate type of transform can cause excessive buffering
-- here.  For example, imagine a stream where every byte of input is
-- interpreted as an integer from 0-255, and then results in that many
-- bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
-- 1kb of data being output.  In this case, you could write a very small
-- amount of input, and end up with a very large amount of output.  In
-- such a pathological inflating mechanism, there'd be no way to tell
-- the system to stop doing the transform.  A single 4MB write could
-- cause the system to run out of memory.
--
-- However, even in such a pathological case, only a single written chunk
-- would be consumed, and then the rest would wait (un-transformed) until
-- the results of the previous transformed chunk were consumed.

function (_ENV)
local string, math, print, type, pairs = nil, nil, nil, nil, nil;
local _module = _obj({exports=_obj({})}); local exports, module = _module.exports, _module;

local Duplex, util, TransformState, afterTransform, Transform, done = Duplex, util, TransformState, afterTransform, Transform, done;
TransformState = (function (this, options, stream)
local TransformState = _debug.getinfo(1, 'f').func;
(this).afterTransform = (function (this, er, data)
if true then return afterTransform(global, stream, er, data); end;
end);
(this).needTransform = (false);
(this).transforming = (false);
(this).writecb = (null);
(this).writechunk = (null);
end);
afterTransform = (function (this, stream, er, data)
local afterTransform = _debug.getinfo(1, 'f').func;
local ts, cb, rs = ts, cb, rs;
ts = (stream)._transformState;
(ts).transforming = (false);
cb = (ts).writecb;
if (not _truthy(cb)) then
if true then return stream:emit(("error"), _new(Error, ("no writecb in Transform class"))); end;
end
(ts).writechunk = (null);
(ts).writecb = (null);
if _truthy((data ~= (null)) and (data ~= undefined)) then
if stream:push(data) then end;
end
if _truthy(cb) then
if cb(global, er) then end;
end
rs = (stream)._readableState;
(rs).reading = (false);
if _truthy((rs).needReadable or ((rs).length < (rs).highWaterMark)) then
if (function () local base, prop = stream, "_read"; return base[prop](base, rs.highWaterMark); end)() then end;
end
end);
Transform = (function (this, options)
local Transform = _debug.getinfo(1, 'f').func;
local ts, stream = ts, stream;
if (not _truthy(_instanceof(this, Transform))) then
if true then return _new(Transform, options); end;
end
if Duplex:call(this, options) then end;
ts = (function () local _r = _new(TransformState, options, this); (this)._transformState = _r; return _r; end)();
stream = this;
((this)._readableState).needReadable = (true);
((this)._readableState).sync = (false);
if this:once(("finish"), (function (this)
if (("function") == _typeof((this)._flush)) then
if (function () local base, prop = this, "_flush"; return base[prop](base, (function (this, er)
if done(global, stream, er) then end;
end)); end)() then end;
else
if done(global, stream) then end;
end
end)) then end;
end);
done = (function (this, stream, er)
local done = _debug.getinfo(1, 'f').func;
local ws, rs, ts = ws, rs, ts;
if _truthy(er) then
if true then return stream:emit(("error"), er); end;
end
ws = (stream)._writableState;
rs = (stream)._readableState;
ts = (stream)._transformState;
if _truthy((ws).length) then
_error(_new(Error, ("calling transform done when ws.length != 0")))
end
if _truthy((ts).transforming) then
_error(_new(Error, ("calling transform done when still transforming")))
end
if true then return stream:push((null)); end;
end);
(module).exports = Transform;
Duplex = require(global, ("./_stream_duplex"));
util = require(global, ("util"));
if util:inherits(Transform, Duplex) then end;
((Transform).prototype).push = (function (this, chunk, encoding)
((this)._transformState).needTransform = (false);
if true then return ((Duplex).prototype).push:call(this, chunk, encoding); end;
end);
((Transform).prototype)._transform = (function (this, chunk, encoding, cb)
_error(_new(Error, ("not implemented")))
end);
((Transform).prototype)._write = (function (this, chunk, encoding, cb)
local ts, rs = ts, rs;
ts = (this)._transformState;
(ts).writecb = cb;
(ts).writechunk = chunk;
(ts).writeencoding = encoding;
if (not _truthy((ts).transforming)) then
rs = (this)._readableState;
if _truthy((ts).needTransform or (rs).needReadable or ((rs).length < (rs).highWaterMark)) then
if (function () local base, prop = this, "_read"; return base[prop](base, rs.highWaterMark); end)() then end;
end
end
end);
((Transform).prototype)._read = (function (this, n)
local ts = ts;
ts = (this)._transformState;
if _truthy((ts).writechunk and (ts).writecb and (not _truthy((ts).transforming))) then
(ts).transforming = (true);
if (function () local base, prop = this, "_transform"; return base[prop](base, ts.writechunk, ts.writeencoding, ts.afterTransform); end)() then end;
else
(ts).needTransform = (true);
end
end);

return _module.exports;
end