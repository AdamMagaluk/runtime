-- Copyright Joyent, Inc. and other Node contributors.
--
-- Permission is hereby granted, free of charge, to any person obtaining a
-- copy of this software and associated documentation files (the
-- "Software"), to deal in the Software without restriction, including
-- without limitation the rights to use, copy, modify, merge, publish,
-- distribute, sublicense, and/or sell copies of the Software, and to permit
-- persons to whom the Software is furnished to do so, subject to the
-- following conditions:
--
-- The above copyright notice and this permission notice shall be included
-- in all copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-- OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-- MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
-- NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
-- DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
-- OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
-- USE OR OTHER DEALINGS IN THE SOFTWARE.

-- A bit simpler than readable streams.
-- Implement an async ._write(chunk, cb), and it'll handle all
-- the drain event emission and buffering.

function (_ENV)
local string, math, print, type, pairs = nil, nil, nil, nil, nil;
local _module = _obj({exports=_obj({})}); local exports, module = _module.exports, _module;

local util, assert, Stream, WriteReq, WritableState, Writable, writeAfterEnd, validChunk, decodeChunk, writeOrBuffer, doWrite, onwriteError, onwriteStateUpdate, onwrite, afterWrite, onwriteDrain, clearBuffer, needFinish, finishMaybe, endWritable = util, assert, Stream, WriteReq, WritableState, Writable, writeAfterEnd, validChunk, decodeChunk, writeOrBuffer, doWrite, onwriteError, onwriteStateUpdate, onwrite, afterWrite, onwriteDrain, clearBuffer, needFinish, finishMaybe, endWritable;
WriteReq = (function (this, chunk, encoding, cb)
local WriteReq = _debug.getinfo(1, 'f').func;
(this).chunk = chunk;
(this).encoding = encoding;
(this).callback = cb;
end);
WritableState = (function (this, options, stream)
local WritableState = _debug.getinfo(1, 'f').func;
local hwm, noDecode = hwm, noDecode;
options = options or _obj({
  });
hwm = (options).highWaterMark;
(this).highWaterMark = (_truthy(hwm or (hwm == (0))) and {hwm} or {((16) * (1024))})[1];
(this).objectMode = (not _truthy((not _truthy((options).objectMode))));
(this).highWaterMark = _bit.bnot(_bit.bnot((this).highWaterMark));
(this).needDrain = (false);
(this).ending = (false);
(this).ended = (false);
(this).finished = (false);
noDecode = ((options).decodeStrings == (false));
(this).decodeStrings = (not _truthy(noDecode));
(this).defaultEncoding = (options).defaultEncoding or ("utf8");
(this).length = (0);
(this).writing = (false);
(this).sync = (true);
(this).bufferProcessing = (false);
(this).onwrite = (function (this, er)
if onwrite(global, stream, er) then end;
end);
(this).writecb = (null);
(this).writelen = (0);
(this).buffer = _arr({});
end);
Writable = (function (this, options)
local Writable = _debug.getinfo(1, 'f').func;
if _truthy((not _truthy(_instanceof(this, Writable))) and (not _truthy(_instanceof(this, require(global, ("./_stream_duplex")))))) then
if true then return _new(Writable, options); end;
end
(this)._writableState = _new(WritableState, options, this);
(this).writable = (true);
if Stream:call(this) then end;
end);
writeAfterEnd = (function (this, stream, state, cb)
local writeAfterEnd = _debug.getinfo(1, 'f').func;
local er = er;
er = _new(Error, ("write after end"));
if stream:emit(("error"), er) then end;
if process:nextTick((function (this)
if cb(global, er) then end;
end)) then end;
end);
validChunk = (function (this, stream, state, chunk, cb)
local validChunk = _debug.getinfo(1, 'f').func;
local valid, er = valid, er;
valid = (true);
if _truthy((not _truthy(Buffer:isBuffer(chunk))) and (("string") ~= _typeof(chunk)) and (chunk ~= (null)) and (chunk ~= undefined) and (not _truthy((state).objectMode))) then
er = _new(TypeError, ("Invalid non-string/buffer chunk"));
if stream:emit(("error"), er) then end;
if process:nextTick((function (this)
if cb(global, er) then end;
end)) then end;
valid = (false);
end
if true then return valid; end;
end);
decodeChunk = (function (this, state, chunk, encoding)
local decodeChunk = _debug.getinfo(1, 'f').func;
if _truthy((not _truthy((state).objectMode)) and ((state).decodeStrings ~= (false)) and (_typeof(chunk) == ("string"))) then
chunk = _new(Buffer, chunk, encoding);
end
if true then return chunk; end;
end);
writeOrBuffer = (function (this, stream, state, chunk, encoding, cb)
local writeOrBuffer = _debug.getinfo(1, 'f').func;
local len, ret = len, ret;
chunk = decodeChunk(global, state, chunk, encoding);
len = (_truthy((state).objectMode) and {(1)} or {(chunk).length})[1];
(state).length = (state).length + len;
ret = ((state).length < (state).highWaterMark);
(state).needDrain = (not _truthy(ret));
if _truthy((state).writing) then
if (state).buffer:push(_new(WriteReq, chunk, encoding, cb)) then end;
else
if doWrite(global, stream, state, len, chunk, encoding, cb) then end;
end
if true then return ret; end;
end);
doWrite = (function (this, stream, state, len, chunk, encoding, cb)
local doWrite = _debug.getinfo(1, 'f').func;
(state).writelen = len;
(state).writecb = cb;
(state).writing = (true);
(state).sync = (true);
if (function () local base, prop = stream, "_write"; return base[prop](base, chunk, encoding, state.onwrite); end)() then end;
(state).sync = (false);
end);
onwriteError = (function (this, stream, state, sync, er, cb)
local onwriteError = _debug.getinfo(1, 'f').func;
if _truthy(sync) then
if process:nextTick((function (this)
if cb(global, er) then end;
end)) then end;
else
if cb(global, er) then end;
end
if stream:emit(("error"), er) then end;
end);
onwriteStateUpdate = (function (this, state)
local onwriteStateUpdate = _debug.getinfo(1, 'f').func;
(state).writing = (false);
(state).writecb = (null);
(state).length = (state).length - (state).writelen;
(state).writelen = (0);
end);
onwrite = (function (this, stream, er)
local onwrite = _debug.getinfo(1, 'f').func;
local state, sync, cb, finished = state, sync, cb, finished;
state = (stream)._writableState;
sync = (state).sync;
cb = (state).writecb;
if onwriteStateUpdate(global, state) then end;
if _truthy(er) then
if onwriteError(global, stream, state, sync, er, cb) then end;
else
finished = needFinish(global, stream, state);
if _truthy((not _truthy(finished)) and (not _truthy((state).bufferProcessing)) and ((state).buffer).length) then
if clearBuffer(global, stream, state) then end;
end
if _truthy(sync) then
if process:nextTick((function (this)
if afterWrite(global, stream, state, finished, cb) then end;
end)) then end;
else
if afterWrite(global, stream, state, finished, cb) then end;
end
end
end);
afterWrite = (function (this, stream, state, finished, cb)
local afterWrite = _debug.getinfo(1, 'f').func;
if (not _truthy(finished)) then
if onwriteDrain(global, stream, state) then end;
end
if cb(global) then end;
if _truthy(finished) then
if finishMaybe(global, stream, state) then end;
end
end);
onwriteDrain = (function (this, stream, state)
local onwriteDrain = _debug.getinfo(1, 'f').func;
if _truthy(((state).length == (0)) and (state).needDrain) then
(state).needDrain = (false);
if stream:emit(("drain")) then end;
end
end);
clearBuffer = (function (this, stream, state)
local clearBuffer = _debug.getinfo(1, 'f').func;
local c, entry, chunk, encoding, cb, len = c, entry, chunk, encoding, cb, len;
(state).bufferProcessing = (true);
c = (0);
while (c < ((state).buffer).length) do

entry = ((state).buffer)[c];
chunk = (entry).chunk;
encoding = (entry).encoding;
cb = (entry).callback;
len = (_truthy((state).objectMode) and {(1)} or {(chunk).length})[1];
if doWrite(global, stream, state, len, chunk, encoding, cb) then end;
if _truthy((state).writing) then
(function () local _r = c; c = _r + 1; return _r end)();
_c = _break; break;
end

if (function () local _r = c; c = _r + 1; return _r end)() then end;
end
(state).bufferProcessing = (false);
if (c < ((state).buffer).length) then
(state).buffer = (state).buffer:slice(c);
else
((state).buffer).length = (0);
end
end);
needFinish = (function (this, stream, state)
local needFinish = _debug.getinfo(1, 'f').func;
if true then return (state).ending and ((state).length == (0)) and (not _truthy((state).finished)) and (not _truthy((state).writing)); end;
end);
finishMaybe = (function (this, stream, state)
local finishMaybe = _debug.getinfo(1, 'f').func;
local need = need;
need = needFinish(global, stream, state);
if _truthy(need) then
(state).finished = (true);
if stream:emit(("finish")) then end;
end
if true then return need; end;
end);
endWritable = (function (this, stream, state, cb)
local endWritable = _debug.getinfo(1, 'f').func;
(state).ending = (true);
if finishMaybe(global, stream, state) then end;
if _truthy(cb) then
if _truthy((state).finished) then
if process:nextTick(cb) then end;
else
if stream:once(("finish"), cb) then end;
end
end
(state).ended = (true);
end);
(module).exports = Writable;
(Writable).WritableState = WritableState;
util = require(global, ("util"));
assert = require(global, ("assert"));
Stream = require(global, ("stream"));
if util:inherits(Writable, Stream) then end;
((Writable).prototype).pipe = (function (this)
if this:emit(("error"), _new(Error, ("Cannot pipe. Not readable."))) then end;
end);
((Writable).prototype).write = (function (this, chunk, encoding, cb)
local state, ret = state, ret;
state = (this)._writableState;
ret = (false);
if (_typeof(encoding) == ("function")) then
cb = encoding;
encoding = (null);
end
if _truthy(Buffer:isBuffer(chunk)) then
encoding = ("buffer");
else
if (not _truthy(encoding)) then
encoding = (state).defaultEncoding;
end
end
if (_typeof(cb) ~= ("function")) then
cb = (function (this)

end);
end
if _truthy((state).ended) then
if writeAfterEnd(global, this, state, cb) then end;
else
if _truthy(validChunk(global, this, state, chunk, cb)) then
ret = writeOrBuffer(global, this, state, chunk, encoding, cb);
end
end
if true then return ret; end;
end);
((Writable).prototype)._write = (function (this, chunk, encoding, cb)
if cb(global, _new(Error, ("not implemented"))) then end;
end);
((Writable).prototype)["end"] = (function (this, chunk, encoding, cb)
local state = state;
state = (this)._writableState;
if (_typeof(chunk) == ("function")) then
cb = chunk;
chunk = (null);
encoding = (null);
else
if (_typeof(encoding) == ("function")) then
cb = encoding;
encoding = (null);
end
end
if _truthy((_typeof(chunk) ~= ("undefined")) and (chunk ~= (null))) then
if this:write(chunk, encoding) then end;
end
if _truthy((not _truthy((state).ending)) and (not _truthy((state).finished))) then
if endWritable(global, this, state, cb) then end;
end
end);

return _module.exports;
end