-- Copyright Joyent, Inc. and other Node contributors.
--
-- Permission is hereby granted, free of charge, to any person obtaining a
-- copy of this software and associated documentation files (the
-- "Software"), to deal in the Software without restriction, including
-- without limitation the rights to use, copy, modify, merge, publish,
-- distribute, sublicense, and/or sell copies of the Software, and to permit
-- persons to whom the Software is furnished to do so, subject to the
-- following conditions:
--
-- The above copyright notice and this permission notice shall be included
-- in all copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-- OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-- MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
-- NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
-- DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
-- OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
-- USE OR OTHER DEALINGS IN THE SOFTWARE.

function (_ENV)
local string, math, print, type, pairs = nil, nil, nil, nil, nil;
local _module = _obj({exports=_obj({})}); local exports, module = _module.exports, _module;

local path, assert, util, i, protoCtrChain, mustCallChecks, runCallChecks = path, assert, util, i, protoCtrChain, mustCallChecks, runCallChecks;
protoCtrChain = (function (this, o)
local protoCtrChain = _debug.getinfo(1, 'f').func;
local result = result;
result = _arr({});

while _truthy(o) do

if result:push(o.constructor) then end;

if (function () local _r = (o).__proto__; o = _r; return _r; end)() then end;
end
if true then return result:join(); end;
end);
runCallChecks = (function (this)
local runCallChecks = _debug.getinfo(1, 'f').func;
local failed = failed;
failed = mustCallChecks:filter((function (this, context)
if true then return ((context).actual ~= (context).expected); end;
end));
if failed:forEach((function (this, context)
if console:log(("Mismatched %s function calls. Expected %d, actual %d."), context.name, context.expected, context.actual) then end;
if console:log((context).stack:split(("\n")):slice((2)):join(("\n"))) then end;
end)) then end;
if _truthy((failed).length) then
if process:exit((1)) then end;
end
end);
path = require(global, ("path"));
assert = require(global, ("assert"));
(exports).testDir = path:dirname(____filename);
(exports).fixturesDir = path:join(exports.testDir, ("fixtures"));
(exports).libDir = path:join(exports.testDir, ("../lib"));
(exports).tmpDir = path:join(exports.testDir, ("tmp"));
(exports).PORT = (12346);
if ((process).platform == ("win32")) then
(exports).PIPE = ("\\\\.\\pipe\\libuv-test");
else
(exports).PIPE = ((exports).tmpDir + ("/test.sock"));
end
util = require(global, ("util"));
for i in _pairs(util) do
(exports)[i] = (util)[i];
end
(exports).indirectInstanceOf = (function (this, obj, cls)
local clsChain, objChain = clsChain, objChain;
if _instanceof(obj, cls) then
if true then return (true); end;
end
clsChain = protoCtrChain(global, cls.prototype);
objChain = protoCtrChain(global, obj);
if true then return (objChain:slice((-(clsChain).length)) == clsChain); end;
end);
(exports).ddCommand = (function (this, filename, kilobytes)
local p = p;
if ((process).platform == ("win32")) then
p = path:resolve(exports.fixturesDir, ("create-file.js"));
if true then return (((((((("\"") + ((process).argv)[(0)]) + ("\" \"")) + p) + ("\" \"")) +
           filename) + ("\" ")) + ((kilobytes * (1024)))); end;
else
if true then return (((("dd if=/dev/zero of=\"") + filename) + ("\" bs=1024 count=")) + kilobytes); end;
end
end);
(exports).spawnPwd = (function (this, options)
local spawn = spawn;
spawn = (require(global, ("child_process"))).spawn;
if ((process).platform == ("win32")) then
if true then return spawn(global, ("cmd.exe"), _arr({[0]=("/c"), ("cd")}), options); end;
else
if true then return spawn(global, ("pwd"), _arr({}), options); end;
end
end);
(exports).globalCheck = (true);
if process:on(("exit"), (function (this)
local knownGlobals, x, found, y = knownGlobals, x, found, y;
if (not _truthy((exports).globalCheck)) then
if true then return; end;
end
knownGlobals = _arr({[0]=setTimeout, setInterval, (global).setImmediate, clearTimeout, clearInterval, (global).clearImmediate, console, Buffer, process, global});
if _truthy((global).errno) then
if knownGlobals:push(errno) then end;
end
if _truthy((global).gc) then
if knownGlobals:push(gc) then end;
end
if _truthy((global).DTRACE_HTTP_SERVER_RESPONSE) then
if knownGlobals:push(DTRACE__HTTP__SERVER__RESPONSE) then end;
if knownGlobals:push(DTRACE__HTTP__SERVER__REQUEST) then end;
if knownGlobals:push(DTRACE__HTTP__CLIENT__RESPONSE) then end;
if knownGlobals:push(DTRACE__HTTP__CLIENT__REQUEST) then end;
if knownGlobals:push(DTRACE__NET__STREAM__END) then end;
if knownGlobals:push(DTRACE__NET__SERVER__CONNECTION) then end;
if knownGlobals:push(DTRACE__NET__SOCKET__READ) then end;
if knownGlobals:push(DTRACE__NET__SOCKET__WRITE) then end;
end
if _truthy((global).COUNTER_NET_SERVER_CONNECTION) then
if knownGlobals:push(COUNTER__NET__SERVER__CONNECTION) then end;
if knownGlobals:push(COUNTER__NET__SERVER__CONNECTION__CLOSE) then end;
if knownGlobals:push(COUNTER__HTTP__SERVER__REQUEST) then end;
if knownGlobals:push(COUNTER__HTTP__SERVER__RESPONSE) then end;
if knownGlobals:push(COUNTER__HTTP__CLIENT__REQUEST) then end;
if knownGlobals:push(COUNTER__HTTP__CLIENT__RESPONSE) then end;
end
if _truthy((global).ArrayBuffer) then
if knownGlobals:push(ArrayBuffer) then end;
if knownGlobals:push(Int8Array) then end;
if knownGlobals:push(Uint8Array) then end;
if knownGlobals:push(Uint8ClampedArray) then end;
if knownGlobals:push(Int16Array) then end;
if knownGlobals:push(Uint16Array) then end;
if knownGlobals:push(Int32Array) then end;
if knownGlobals:push(Uint32Array) then end;
if knownGlobals:push(Float32Array) then end;
if knownGlobals:push(Float64Array) then end;
if knownGlobals:push(DataView) then end;
end
for x in _pairs(global) do
found = (false);
for y in _pairs(knownGlobals) do
if ((global)[x] == (knownGlobals)[y]) then
found = (true);
_c = _break; break;
end
end
if (not _truthy(found)) then
if (function () local base, prop = console, "error"; return base[prop](base, ("Unknown global: %s"), x); end)() then end;
if assert:ok((false), ("Unknown global found")) then end;
end
end
end)) then end;
mustCallChecks = _arr({});
(exports).mustCall = (function (this, fn, expected)
local context = context;
if (_typeof(expected) ~= ("number")) then
expected = (1);
end
context = _obj({
  ["expected"]=expected,
  ["actual"]=0,
  ["stack"]=(_new(Error)).stack,
  ["name"]=(fn).name or ("<anonymous>")});
if ((mustCallChecks).length == (0)) then
if process:on(("exit"), runCallChecks) then end;
end
if mustCallChecks:push(context) then end;
if true then return (function (this, ...)
local arguments = _arguments(...);
(function () local _r = (context).actual; (context).actual = _r + 1; return _r end)();
if true then return fn:apply(this, arguments); end;
end); end;
end);

return _module.exports;
end