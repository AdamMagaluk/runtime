-- Copyright Joyent, Inc. and other Node contributors.
--
-- Permission is hereby granted, free of charge, to any person obtaining a
-- copy of this software and associated documentation files (the
-- "Software"), to deal in the Software without restriction, including
-- without limitation the rights to use, copy, modify, merge, publish,
-- distribute, sublicense, and/or sell copies of the Software, and to permit
-- persons to whom the Software is furnished to do so, subject to the
-- following conditions:
--
-- The above copyright notice and this permission notice shall be included
-- in all copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-- OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-- MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
-- NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
-- DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
-- OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
-- USE OR OTHER DEALINGS IN THE SOFTWARE.


function (_ENV)
local string, math, print, type, pairs = nil, nil, nil, nil, nil;
local _module = _obj({exports=_obj({})}); local exports, module = _module.exports, _module;

local common, Readable, Writable, assert, tests, count, test, run, toArray, fromArray, noop = common, Readable, Writable, assert, tests, count, test, run, toArray, fromArray, noop;
test = (function (this, name, fn)
local test = _debug.getinfo(1, 'f').func;
(function () local _r = count; count = _r + 1; return _r end)();
if tests:push(_arr({[0]=name, fn})) then end;
end);
run = (function (this)
local run = _debug.getinfo(1, 'f').func;
local next, name, fn = next, name, fn;
next = tests:shift();
if (not (next)) then
if true then return (function () local base, prop = console, "error"; return base[prop](base, ("ok")); end)(); end;
end
name = (next)[(0)];
fn = (next)[(1)];
if console:log(("# %s"), name) then end;
if fn(global, _obj({
  ["same"]=(assert).deepEqual,
  ["equal"]=(assert).equal,
  ["end"]=(function (this)
(function () local _r = count; count = _r - 1; return _r end)();
if run(global) then end;
end)})) then end;
end);
toArray = (function (this, callback)
local toArray = _debug.getinfo(1, 'f').func;
local stream, list = stream, list;
stream = _new(Writable, _obj({
  ["objectMode"]=true}));
list = _arr({});
(stream).write = (function (this, chunk)
if list:push(chunk) then end;
end);
(stream)["end"] = (function (this)
if callback(global, list) then end;
end);
if true then return stream; end;
end);
fromArray = (function (this, list)
local fromArray = _debug.getinfo(1, 'f').func;
local r = r;
r = _new(Readable, _obj({
  ["objectMode"]=true}));
(r)._read = noop;
if list:forEach((function (this, chunk)
if r:push(chunk) then end;
end)) then end;
if r:push((null)) then end;
if true then return r; end;
end);
noop = (function (this)
local noop = _debug.getinfo(1, 'f').func;

end);
common = require(global, ("../common.js"));
Readable = require(global, ("../../lib/_stream_readable"));
Writable = require(global, ("../../lib/_stream_writable"));
assert = require(global, ("assert"));
tests = _arr({});
count = (0);
if process:on(("exit"), (function (this)
if assert:equal(count, (0)) then end;
end)) then end;
if process:nextTick(run) then end;
if test(global, ("can read objects from stream"), (function (this, t)
local r, v1, v2, v3 = r, v1, v2, v3;
r = fromArray(global, _arr({[0]=_obj({
  ["one"]=("1")}), _obj({
  ["two"]=("2")})}));
v1 = r:read();
v2 = r:read();
v3 = r:read();
if assert:deepEqual(v1, _obj({
  ["one"]=("1")})) then end;
if assert:deepEqual(v2, _obj({
  ["two"]=("2")})) then end;
if assert:deepEqual(v3, (null)) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end)) then end;
if test(global, ("can pipe objects into stream"), (function (this, t)
local r = r;
r = fromArray(global, _arr({[0]=_obj({
  ["one"]=("1")}), _obj({
  ["two"]=("2")})}));
if r:pipe(toArray(global, (function (this, list)
if assert:deepEqual(list, _arr({[0]=_obj({
  ["one"]=("1")}), _obj({
  ["two"]=("2")})})) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end))) then end;
end)) then end;
if test(global, ("read(n) is ignored"), (function (this, t)
local r, value = r, value;
r = fromArray(global, _arr({[0]=_obj({
  ["one"]=("1")}), _obj({
  ["two"]=("2")})}));
value = r:read((2));
if assert:deepEqual(value, _obj({
  ["one"]=("1")})) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end)) then end;
if test(global, ("can read objects from _read (sync)"), (function (this, t)
local r, list = r, list;
r = _new(Readable, _obj({
  ["objectMode"]=true}));
list = _arr({[0]=_obj({
  ["one"]=("1")}), _obj({
  ["two"]=("2")})});
(r)._read = (function (this, n)
local item = item;
item = list:shift();
if r:push(item or (null)) then end;
end);
if r:pipe(toArray(global, (function (this, list)
if assert:deepEqual(list, _arr({[0]=_obj({
  ["one"]=("1")}), _obj({
  ["two"]=("2")})})) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end))) then end;
end)) then end;
if test(global, ("can read objects from _read (async)"), (function (this, t)
local r, list = r, list;
r = _new(Readable, _obj({
  ["objectMode"]=true}));
list = _arr({[0]=_obj({
  ["one"]=("1")}), _obj({
  ["two"]=("2")})});
(r)._read = (function (this, n)
local item = item;
item = list:shift();
if process:nextTick((function (this)
if r:push(item or (null)) then end;
end)) then end;
end);
if r:pipe(toArray(global, (function (this, list)
if assert:deepEqual(list, _arr({[0]=_obj({
  ["one"]=("1")}), _obj({
  ["two"]=("2")})})) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end))) then end;
end)) then end;
if test(global, ("can read strings as objects"), (function (this, t)
local r, list = r, list;
r = _new(Readable, _obj({
  ["objectMode"]=true}));
(r)._read = noop;
list = _arr({[0]=("one"), ("two"), ("three")});
if list:forEach((function (this, str)
if r:push(str) then end;
end)) then end;
if r:push((null)) then end;
if r:pipe(toArray(global, (function (this, array)
if assert:deepEqual(array, list) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end))) then end;
end)) then end;
if test(global, ("read(0) for object streams"), (function (this, t)
local r, v = r, v;
r = _new(Readable, _obj({
  ["objectMode"]=true}));
(r)._read = noop;
if r:push(("foobar")) then end;
if r:push((null)) then end;
v = r:read((0));
if r:pipe(toArray(global, (function (this, array)
if assert:deepEqual(array, _arr({[0]=("foobar")})) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end))) then end;
end)) then end;
if test(global, ("falsey values"), (function (this, t)
local r = r;
r = _new(Readable, _obj({
  ["objectMode"]=true}));
(r)._read = noop;
if r:push((false)) then end;
if r:push((0)) then end;
if r:push(("")) then end;
if r:push((null)) then end;
if r:pipe(toArray(global, (function (this, array)
if assert:deepEqual(array, _arr({[0]=(false), (0), ("")})) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end))) then end;
end)) then end;
if test(global, ("high watermark _read"), (function (this, t)
local r, calls, list, v, v2 = r, calls, list, v, v2;
r = _new(Readable, _obj({
  ["highWaterMark"]=6,
  ["objectMode"]=true}));
calls = (0);
list = _arr({[0]=("1"), ("2"), ("3"), ("4"), ("5"), ("6"), ("7"), ("8")});
(r)._read = (function (this, n)
(function () local _r = calls; calls = _r + 1; return _r end)();
end);
if list:forEach((function (this, c)
if r:push(c) then end;
end)) then end;
v = r:read();
if assert:equal(calls, (0)) then end;
if assert:equal(v, ("1")) then end;
v2 = r:read();
if assert:equal(calls, (1)) then end;
if assert:equal(v2, ("2")) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end)) then end;
if test(global, ("high watermark push"), (function (this, t)
local r, i, bool = r, i, bool;
r = _new(Readable, _obj({
  ["highWaterMark"]=6,
  ["objectMode"]=true}));
(r)._read = (function (this, n)

end);
i = (0);
while (i < (6)) do

bool = r:push(i);
if assert:equal(bool, ((i == (5)) and {(false)} or {(true)})[1]) then end;

if (function () local _r = i; i = _r + 1; return _r end)() then end;
end
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end)) then end;
if test(global, ("can write objects to stream"), (function (this, t)
local w = w;
w = _new(Writable, _obj({
  ["objectMode"]=true}));
(w)._write = (function (this, chunk, encoding, cb)
if assert:deepEqual(chunk, _obj({
  ["foo"]=("bar")})) then end;
if cb(global) then end;
end);
if w:on(("finish"), (function (this)
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end)) then end;
if w:write(_obj({
  ["foo"]=("bar")})) then end;
if (function () local base, prop = w, "end"; return base[prop](base); end)() then end;
end)) then end;
if test(global, ("can write multiple objects to stream"), (function (this, t)
local w, list = w, list;
w = _new(Writable, _obj({
  ["objectMode"]=true}));
list = _arr({});
(w)._write = (function (this, chunk, encoding, cb)
if list:push(chunk) then end;
if cb(global) then end;
end);
if w:on(("finish"), (function (this)
if assert:deepEqual(list, _arr({[0]=(0), (1), (2), (3), (4)})) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end)) then end;
if w:write((0)) then end;
if w:write((1)) then end;
if w:write((2)) then end;
if w:write((3)) then end;
if w:write((4)) then end;
if (function () local base, prop = w, "end"; return base[prop](base); end)() then end;
end)) then end;
if test(global, ("can write strings as objects"), (function (this, t)
local w, list = w, list;
w = _new(Writable, _obj({
  ["objectMode"]=true}));
list = _arr({});
(w)._write = (function (this, chunk, encoding, cb)
if list:push(chunk) then end;
if process:nextTick(cb) then end;
end);
if w:on(("finish"), (function (this)
if assert:deepEqual(list, _arr({[0]=("0"), ("1"), ("2"), ("3"), ("4")})) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end)) then end;
if w:write(("0")) then end;
if w:write(("1")) then end;
if w:write(("2")) then end;
if w:write(("3")) then end;
if w:write(("4")) then end;
if (function () local base, prop = w, "end"; return base[prop](base); end)() then end;
end)) then end;
if test(global, ("buffers finish until cb is called"), (function (this, t)
local w, called = w, called;
w = _new(Writable, _obj({
  ["objectMode"]=true}));
called = (false);
(w)._write = (function (this, chunk, encoding, cb)
if assert:equal(chunk, ("foo")) then end;
if process:nextTick((function (this)
called = (true);
if cb(global) then end;
end)) then end;
end);
if w:on(("finish"), (function (this)
if assert:equal(called, (true)) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end)) then end;
if w:write(("foo")) then end;
if (function () local base, prop = w, "end"; return base[prop](base); end)() then end;
end)) then end;

return _module.exports;
end