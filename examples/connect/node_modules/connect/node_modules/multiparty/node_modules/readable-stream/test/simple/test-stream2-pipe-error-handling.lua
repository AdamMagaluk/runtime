-- Copyright Joyent, Inc. and other Node contributors.
--
-- Permission is hereby granted, free of charge, to any person obtaining a
-- copy of this software and associated documentation files (the
-- "Software"), to deal in the Software without restriction, including
-- without limitation the rights to use, copy, modify, merge, publish,
-- distribute, sublicense, and/or sell copies of the Software, and to permit
-- persons to whom the Software is furnished to do so, subject to the
-- following conditions:
--
-- The above copyright notice and this permission notice shall be included
-- in all copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-- OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-- MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
-- NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
-- DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
-- OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
-- USE OR OTHER DEALINGS IN THE SOFTWARE.

function (_ENV)
local string, math, print, type, pairs = nil, nil, nil, nil, nil;
local _module = _obj({exports=_obj({})}); local exports, module = _module.exports, _module;

local common, assert, stream, testErrorListenerCatches, testErrorWithoutListenerThrows = common, assert, stream, testErrorListenerCatches, testErrorWithoutListenerThrows;
common = require(global, ("../common"));
assert = require(global, ("assert"));
stream = require(global, ("../../readable"));
if (function (this)
local testErrorListenerCatches = _debug.getinfo(1, 'f').func;
local count, source, unpipedDest, dest, gotErr, unpipedSource, err = count, source, unpipedDest, dest, gotErr, unpipedSource, err;
count = (1000);
source = _new((stream).Readable);
(source)._read = (function (this, n)
n = Math:min(count, n);
count = count - n;
if source:push(_new(Buffer, n)) then end;
end);
unpipedDest = nil;
(source).unpipe = (function (this, dest)
unpipedDest = dest;
if (((stream).Readable).prototype).unpipe:call(this, dest) then end;
end);
dest = _new((stream).Writable);
(dest)._write = (function (this, chunk, encoding, cb)
if cb(global) then end;
end);
if source:pipe(dest) then end;
gotErr = (null);
if dest:on(("error"), (function (this, err)
gotErr = err;
end)) then end;
unpipedSource = nil;
if dest:on(("unpipe"), (function (this, src)
unpipedSource = src;
end)) then end;
err = _new(Error, ("This stream turned into bacon."));
if dest:emit(("error"), err) then end;
if assert:strictEqual(gotErr, err) then end;
if assert:strictEqual(unpipedSource, source) then end;
if assert:strictEqual(unpipedDest, dest) then end;
end)(global) then end;
if (function (this)
local testErrorWithoutListenerThrows = _debug.getinfo(1, 'f').func;
local count, source, unpipedDest, dest, unpipedSource, err, gotErr = count, source, unpipedDest, dest, unpipedSource, err, gotErr;
count = (1000);
source = _new((stream).Readable);
(source)._read = (function (this, n)
n = Math:min(count, n);
count = count - n;
if source:push(_new(Buffer, n)) then end;
end);
unpipedDest = nil;
(source).unpipe = (function (this, dest)
unpipedDest = dest;
if (((stream).Readable).prototype).unpipe:call(this, dest) then end;
end);
dest = _new((stream).Writable);
(dest)._write = (function (this, chunk, encoding, cb)
if cb(global) then end;
end);
if source:pipe(dest) then end;
unpipedSource = nil;
if dest:on(("unpipe"), (function (this, src)
unpipedSource = src;
end)) then end;
err = _new(Error, ("This stream turned into bacon."));
gotErr = (null);
local _e = nil
local _s, _r = _xpcall(function ()
if dest:emit(("error"), err) then end;
    end, function (err)
        _e = err
    end)
if _s == false then
e = _e;
gotErr = e;
end

if assert:strictEqual(gotErr, err) then end;
if assert:strictEqual(unpipedSource, source) then end;
if assert:strictEqual(unpipedDest, dest) then end;
end)(global) then end;

return _module.exports;
end