-- Copyright Joyent, Inc. and other Node contributors.
--
-- Permission is hereby granted, free of charge, to any person obtaining a
-- copy of this software and associated documentation files (the
-- "Software"), to deal in the Software without restriction, including
-- without limitation the rights to use, copy, modify, merge, publish,
-- distribute, sublicense, and/or sell copies of the Software, and to permit
-- persons to whom the Software is furnished to do so, subject to the
-- following conditions:
--
-- The above copyright notice and this permission notice shall be included
-- in all copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-- OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-- MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
-- NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
-- DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
-- OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
-- USE OR OTHER DEALINGS IN THE SOFTWARE.

function (_ENV)
local string, math, print, type, pairs = nil, nil, nil, nil, nil;
local _module = _obj({exports=_obj({})}); local exports, module = _module.exports, _module;

local assert, common, PassThrough, Transform, tests, count, test, run = assert, common, PassThrough, Transform, tests, count, test, run;
test = (function (this, name, fn)
local test = _debug.getinfo(1, 'f').func;
(function () local _r = count; count = _r + 1; return _r end)();
if tests:push(_arr({[0]=name, fn})) then end;
end);
run = (function (this)
local run = _debug.getinfo(1, 'f').func;
local next, name, fn = next, name, fn;
next = tests:shift();
if (not _truthy(next)) then
if true then return (function () local base, prop = console, "error"; return base[prop](base, ("ok")); end)(); end;
end
name = (next)[(0)];
fn = (next)[(1)];
if console:log(("# %s"), name) then end;
if fn(global, _obj({
  ["same"]=(assert).deepEqual,
  ["equal"]=(assert).equal,
  ["ok"]=assert,
  ["end"]=(function (this)
(function () local _r = count; count = _r - 1; return _r end)();
if run(global) then end;
end)})) then end;
end);
assert = require(global, ("assert"));
common = require(global, ("../common.js"));
PassThrough = require(global, ("../../lib/_stream_passthrough"));
Transform = require(global, ("../../lib/_stream_transform"));
tests = _arr({});
count = (0);
if process:on(("exit"), (function (this)
if assert:equal(count, (0)) then end;
end)) then end;
if process:nextTick(run) then end;
if test(global, ("writable side consumption"), (function (this, t)
local tx, transformed, i = tx, transformed, i;
tx = _new(Transform, _obj({
  ["highWaterMark"]=10}));
transformed = (0);
(tx)._transform = (function (this, chunk, encoding, cb)
transformed = transformed + (chunk).length;
if tx:push(chunk) then end;
if cb(global) then end;
end);
i = (1);
while (i <= (10)) do

if tx:write(_new(Buffer, i)) then end;

if (function () local _r = i; i = _r + 1; return _r end)() then end;
end
if (function () local base, prop = tx, "end"; return base[prop](base); end)() then end;
if t:equal((tx)._readableState.length, (10)) then end;
if t:equal(transformed, (10)) then end;
if t:equal(((tx)._transformState).writechunk.length, (5)) then end;
if t:same(((tx)._writableState).buffer:map((function (this, c)
if true then return ((c).chunk).length; end;
end)), _arr({[0]=(6), (7), (8), (9), (10)})) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end)) then end;
if test(global, ("passthrough"), (function (this, t)
local pt = pt;
pt = _new(PassThrough);
if pt:write(_new(Buffer, ("foog"))) then end;
if pt:write(_new(Buffer, ("bark"))) then end;
if pt:write(_new(Buffer, ("bazy"))) then end;
if pt:write(_new(Buffer, ("kuel"))) then end;
if (function () local base, prop = pt, "end"; return base[prop](base); end)() then end;
if t:equal(pt:read((5)):toString(), ("foogb")) then end;
if t:equal(pt:read((5)):toString(), ("arkba")) then end;
if t:equal(pt:read((5)):toString(), ("zykue")) then end;
if t:equal(pt:read((5)):toString(), ("l")) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end)) then end;
if test(global, ("simple transform"), (function (this, t)
local pt = pt;
pt = _new(Transform);
(pt)._transform = (function (this, c, e, cb)
local ret = ret;
ret = _new(Buffer, (c).length);
if ret:fill(("x")) then end;
if pt:push(ret) then end;
if cb(global) then end;
end);
if pt:write(_new(Buffer, ("foog"))) then end;
if pt:write(_new(Buffer, ("bark"))) then end;
if pt:write(_new(Buffer, ("bazy"))) then end;
if pt:write(_new(Buffer, ("kuel"))) then end;
if (function () local base, prop = pt, "end"; return base[prop](base); end)() then end;
if t:equal(pt:read((5)):toString(), ("xxxxx")) then end;
if t:equal(pt:read((5)):toString(), ("xxxxx")) then end;
if t:equal(pt:read((5)):toString(), ("xxxxx")) then end;
if t:equal(pt:read((5)):toString(), ("x")) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end)) then end;
if test(global, ("async passthrough"), (function (this, t)
local pt = pt;
pt = _new(Transform);
(pt)._transform = (function (this, chunk, encoding, cb)
if setTimeout(global, (function (this)
if pt:push(chunk) then end;
if cb(global) then end;
end), (10)) then end;
end);
if pt:write(_new(Buffer, ("foog"))) then end;
if pt:write(_new(Buffer, ("bark"))) then end;
if pt:write(_new(Buffer, ("bazy"))) then end;
if pt:write(_new(Buffer, ("kuel"))) then end;
if (function () local base, prop = pt, "end"; return base[prop](base); end)() then end;
if pt:on(("finish"), (function (this)
if t:equal(pt:read((5)):toString(), ("foogb")) then end;
if t:equal(pt:read((5)):toString(), ("arkba")) then end;
if t:equal(pt:read((5)):toString(), ("zykue")) then end;
if t:equal(pt:read((5)):toString(), ("l")) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end)) then end;
end)) then end;
if test(global, ("assymetric transform (expand)"), (function (this, t)
local pt = pt;
pt = _new(Transform);
(pt)._transform = (function (this, chunk, encoding, cb)
if setTimeout(global, (function (this)
if pt:push(chunk) then end;
if setTimeout(global, (function (this)
if pt:push(chunk) then end;
if cb(global) then end;
end), (10))
     then end;
end), (10)) then end;
end);
if pt:write(_new(Buffer, ("foog"))) then end;
if pt:write(_new(Buffer, ("bark"))) then end;
if pt:write(_new(Buffer, ("bazy"))) then end;
if pt:write(_new(Buffer, ("kuel"))) then end;
if (function () local base, prop = pt, "end"; return base[prop](base); end)() then end;
if pt:on(("finish"), (function (this)
if t:equal(pt:read((5)):toString(), ("foogf")) then end;
if t:equal(pt:read((5)):toString(), ("oogba")) then end;
if t:equal(pt:read((5)):toString(), ("rkbar")) then end;
if t:equal(pt:read((5)):toString(), ("kbazy")) then end;
if t:equal(pt:read((5)):toString(), ("bazyk")) then end;
if t:equal(pt:read((5)):toString(), ("uelku")) then end;
if t:equal(pt:read((5)):toString(), ("el")) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end)) then end;
end)) then end;
if test(global, ("assymetric transform (compress)"), (function (this, t)
local pt = pt;
pt = _new(Transform);
(pt).state = ("");
(pt)._transform = (function (this, chunk, encoding, cb)
local s = s;
if (not _truthy(chunk)) then
chunk = ("");
end
s = chunk:toString();
if setTimeout(global, (function (this)
(this).state = (this).state + s:charAt((0));
if (((this).state).length == (3)) then
if pt:push(_new(Buffer, (this).state)) then end;
(this).state = ("");
end
if cb(global) then end;
end):bind(this), (10)) then end;
end);
(pt)._flush = (function (this, cb)
if pt:push(_new(Buffer, (this).state)) then end;
(this).state = ("");
if cb(global) then end;
end);
if pt:write(_new(Buffer, ("aaaa"))) then end;
if pt:write(_new(Buffer, ("bbbb"))) then end;
if pt:write(_new(Buffer, ("cccc"))) then end;
if pt:write(_new(Buffer, ("dddd"))) then end;
if pt:write(_new(Buffer, ("eeee"))) then end;
if pt:write(_new(Buffer, ("aaaa"))) then end;
if pt:write(_new(Buffer, ("bbbb"))) then end;
if pt:write(_new(Buffer, ("cccc"))) then end;
if pt:write(_new(Buffer, ("dddd"))) then end;
if pt:write(_new(Buffer, ("eeee"))) then end;
if pt:write(_new(Buffer, ("aaaa"))) then end;
if pt:write(_new(Buffer, ("bbbb"))) then end;
if pt:write(_new(Buffer, ("cccc"))) then end;
if pt:write(_new(Buffer, ("dddd"))) then end;
if (function () local base, prop = pt, "end"; return base[prop](base); end)() then end;
if pt:on(("finish"), (function (this)
if t:equal(pt:read((5)):toString(), ("abcde")) then end;
if t:equal(pt:read((5)):toString(), ("abcde")) then end;
if t:equal(pt:read((5)):toString(), ("abcd")) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end)) then end;
end)) then end;
if test(global, ("passthrough event emission"), (function (this, t)
local pt, emits, i = pt, emits, i;
pt = _new(PassThrough);
emits = (0);
if pt:on(("readable"), (function (this)
local state = state;
state = (pt)._readableState;
if (function () local base, prop = console, "error"; return base[prop](base, (">>> emit readable %d"), emits); end)() then end;
(function () local _r = emits; emits = _r + 1; return _r end)();
end)) then end;
i = (0);
if pt:write(_new(Buffer, ("foog"))) then end;
if (function () local base, prop = console, "error"; return base[prop](base, ("need emit 0")); end)() then end;
if pt:write(_new(Buffer, ("bark"))) then end;
if (function () local base, prop = console, "error"; return base[prop](base, ("should have emitted readable now 1 === %d"), emits); end)() then end;
if t:equal(emits, (1)) then end;
if t:equal(pt:read((5)):toString(), ("foogb")) then end;
if t:equal((pt:read((5)) + ("")), ("null")) then end;
if (function () local base, prop = console, "error"; return base[prop](base, ("need emit 1")); end)() then end;
if pt:write(_new(Buffer, ("bazy"))) then end;
if (function () local base, prop = console, "error"; return base[prop](base, ("should have emitted, but not again")); end)() then end;
if pt:write(_new(Buffer, ("kuel"))) then end;
if (function () local base, prop = console, "error"; return base[prop](base, ("should have emitted readable now 2 === %d"), emits); end)() then end;
if t:equal(emits, (2)) then end;
if t:equal(pt:read((5)):toString(), ("arkba")) then end;
if t:equal(pt:read((5)):toString(), ("zykue")) then end;
if t:equal(pt:read((5)), (null)) then end;
if (function () local base, prop = console, "error"; return base[prop](base, ("need emit 2")); end)() then end;
if (function () local base, prop = pt, "end"; return base[prop](base); end)() then end;
if t:equal(emits, (3)) then end;
if t:equal(pt:read((5)):toString(), ("l")) then end;
if t:equal(pt:read((5)), (null)) then end;
if (function () local base, prop = console, "error"; return base[prop](base, ("should not have emitted again")); end)() then end;
if t:equal(emits, (3)) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end)) then end;
if test(global, ("passthrough event emission reordered"), (function (this, t)
local pt, emits = pt, emits;
pt = _new(PassThrough);
emits = (0);
if pt:on(("readable"), (function (this)
if (function () local base, prop = console, "error"; return base[prop](base, ("emit readable"), emits); end)()
     then end;
(function () local _r = emits; emits = _r + 1; return _r end)();
end)) then end;
if pt:write(_new(Buffer, ("foog"))) then end;
if (function () local base, prop = console, "error"; return base[prop](base, ("need emit 0")); end)() then end;
if pt:write(_new(Buffer, ("bark"))) then end;
if (function () local base, prop = console, "error"; return base[prop](base, ("should have emitted readable now 1 === %d"), emits); end)() then end;
if t:equal(emits, (1)) then end;
if t:equal(pt:read((5)):toString(), ("foogb")) then end;
if t:equal(pt:read((5)), (null)) then end;
if (function () local base, prop = console, "error"; return base[prop](base, ("need emit 1")); end)() then end;
if pt:once(("readable"), (function (this)
if t:equal(pt:read((5)):toString(), ("arkba")) then end;
if t:equal(pt:read((5)), (null)) then end;
if (function () local base, prop = console, "error"; return base[prop](base, ("need emit 2")); end)() then end;
if pt:once(("readable"), (function (this)
if t:equal(pt:read((5)):toString(), ("zykue")) then end;
if t:equal(pt:read((5)), (null)) then end;
if pt:once(("readable"), (function (this)
if t:equal(pt:read((5)):toString(), ("l")) then end;
if t:equal(pt:read((5)), (null)) then end;
if t:equal(emits, (4)) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end)) then end;
if (function () local base, prop = pt, "end"; return base[prop](base); end)() then end;
end)) then end;
if pt:write(_new(Buffer, ("kuel"))) then end;
end)) then end;
if pt:write(_new(Buffer, ("bazy"))) then end;
end)) then end;
if test(global, ("passthrough facaded"), (function (this, t)
local pt, datas = pt, datas;
if (function () local base, prop = console, "error"; return base[prop](base, ("passthrough facaded")); end)() then end;
pt = _new(PassThrough);
datas = _arr({});
if pt:on(("data"), (function (this, chunk)
if datas:push(chunk:toString()) then end;
end)) then end;
if pt:on(("end"), (function (this)
if t:same(datas, _arr({[0]=("foog"), ("bark"), ("bazy"), ("kuel")})) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end)) then end;
if pt:write(_new(Buffer, ("foog"))) then end;
if setTimeout(global, (function (this)
if pt:write(_new(Buffer, ("bark"))) then end;
if setTimeout(global, (function (this)
if pt:write(_new(Buffer, ("bazy"))) then end;
if setTimeout(global, (function (this)
if pt:write(_new(Buffer, ("kuel"))) then end;
if setTimeout(global, (function (this)
if (function () local base, prop = pt, "end"; return base[prop](base); end)() then end;
end), (10)) then end;
end), (10)) then end;
end), (10)) then end;
end), (10)) then end;
end)) then end;
if test(global, ("object transform (json parse)"), (function (this, t)
local jp, objects, ended = jp, objects, ended;
if (function () local base, prop = console, "error"; return base[prop](base, ("json parse stream")); end)() then end;
jp = _new(Transform, _obj({
  ["objectMode"]=true}));
(jp)._transform = (function (this, data, encoding, cb)
local _e = nil
local _s, _r = _xpcall(function ()
if jp:push(JSON:parse(data)) then end;
if cb(global) then end;
    end, function (err)
        _e = err
    end)
if _s == false then
er = _e;
if cb(global, er) then end;
end

end);
objects = _arr({[0]=_obj({
  ["foo"]=("bar")}), (100), ("string"), _obj({
  ["nested"]=_obj({
  ["things"]=_arr({[0]=_obj({
  ["foo"]=("bar")}), (100), ("string")})})})});
ended = (false);
if jp:on(("end"), (function (this)
ended = (true);
end)) then end;
if objects:forEach((function (this, obj)
local res = res;
if jp:write(JSON:stringify(obj)) then end;
res = jp:read();
if t:same(res, obj) then end;
end)) then end;
if (function () local base, prop = jp, "end"; return base[prop](base); end)() then end;
if process:nextTick((function (this)
if t:ok(ended) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end))
 then end;
end)) then end;
if test(global, ("object transform (json stringify)"), (function (this, t)
local js, objects, ended = js, objects, ended;
if (function () local base, prop = console, "error"; return base[prop](base, ("json parse stream")); end)() then end;
js = _new(Transform, _obj({
  ["objectMode"]=true}));
(js)._transform = (function (this, data, encoding, cb)
local _e = nil
local _s, _r = _xpcall(function ()
if js:push(JSON:stringify(data)) then end;
if cb(global) then end;
    end, function (err)
        _e = err
    end)
if _s == false then
er = _e;
if cb(global, er) then end;
end

end);
objects = _arr({[0]=_obj({
  ["foo"]=("bar")}), (100), ("string"), _obj({
  ["nested"]=_obj({
  ["things"]=_arr({[0]=_obj({
  ["foo"]=("bar")}), (100), ("string")})})})});
ended = (false);
if js:on(("end"), (function (this)
ended = (true);
end)) then end;
if objects:forEach((function (this, obj)
local res = res;
if js:write(obj) then end;
res = js:read();
if t:equal(res, JSON:stringify(obj)) then end;
end)) then end;
if (function () local base, prop = js, "end"; return base[prop](base); end)() then end;
if process:nextTick((function (this)
if t:ok(ended) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end))
 then end;
end)) then end;

return _module.exports;
end