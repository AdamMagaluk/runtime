-- Copyright Joyent, Inc. and other Node contributors.
--
-- Permission is hereby granted, free of charge, to any person obtaining a
-- copy of this software and associated documentation files (the
-- "Software"), to deal in the Software without restriction, including
-- without limitation the rights to use, copy, modify, merge, publish,
-- distribute, sublicense, and/or sell copies of the Software, and to permit
-- persons to whom the Software is furnished to do so, subject to the
-- following conditions:
--
-- The above copyright notice and this permission notice shall be included
-- in all copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-- OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-- MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
-- NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
-- DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
-- OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
-- USE OR OTHER DEALINGS IN THE SOFTWARE.

function (_ENV)
local string, math, print, type, pairs = nil, nil, nil, nil, nil;
local _module = _obj({exports=_obj({})}); local exports, module = _module.exports, _module;

local Transform, binding, util, assert, zlibBuffer, Deflate, Inflate, Gzip, Gunzip, DeflateRaw, InflateRaw, Unzip, Zlib, reset = Transform, binding, util, assert, zlibBuffer, Deflate, Inflate, Gzip, Gunzip, DeflateRaw, InflateRaw, Unzip, Zlib, reset;
zlibBuffer = (function (this, engine, buffer, callback)
local zlibBuffer = _debug.getinfo(1, 'f').func;
local buffers, nread, flow, onError, onEnd = buffers, nread, flow, onError, onEnd;
flow = (function (this)
local flow = _debug.getinfo(1, 'f').func;
local chunk = chunk;
chunk = nil;
while ((null) ~= (function () local _r = engine:read(); chunk = _r; return _r; end)()) do

if buffers:push(chunk) then end;
nread = nread + (chunk).length;

end
if engine:once(("readable"), flow) then end;
end);
onError = (function (this, err)
local onError = _debug.getinfo(1, 'f').func;
if engine:removeListener(("end"), onEnd) then end;
if engine:removeListener(("readable"), flow) then end;
if callback(global, err) then end;
end);
onEnd = (function (this)
local onEnd = _debug.getinfo(1, 'f').func;
local buf = buf;
buf = Buffer:concat(buffers, nread);
buffers = _arr({});
if callback(global, (null), buf) then end;
end);
buffers = _arr({});
nread = (0);
if engine:on(("error"), onError) then end;
if engine:on(("end"), onEnd) then end;
if (function () local base, prop = engine, "end"; return base[prop](base, buffer); end)() then end;
if flow(global) then end;
end);
Deflate = (function (this, opts)
local Deflate = _debug.getinfo(1, 'f').func;
if (not _truthy(_instanceof(this, Deflate))) then
if true then return _new(Deflate, opts); end;
end
if Zlib:call(this, opts, binding.DEFLATE) then end;
end);
Inflate = (function (this, opts)
local Inflate = _debug.getinfo(1, 'f').func;
if (not _truthy(_instanceof(this, Inflate))) then
if true then return _new(Inflate, opts); end;
end
if Zlib:call(this, opts, binding.INFLATE) then end;
end);
Gzip = (function (this, opts)
local Gzip = _debug.getinfo(1, 'f').func;
if (not _truthy(_instanceof(this, Gzip))) then
if true then return _new(Gzip, opts); end;
end
if Zlib:call(this, opts, binding.GZIP) then end;
end);
Gunzip = (function (this, opts)
local Gunzip = _debug.getinfo(1, 'f').func;
if (not _truthy(_instanceof(this, Gunzip))) then
if true then return _new(Gunzip, opts); end;
end
if Zlib:call(this, opts, binding.GUNZIP) then end;
end);
DeflateRaw = (function (this, opts)
local DeflateRaw = _debug.getinfo(1, 'f').func;
if (not _truthy(_instanceof(this, DeflateRaw))) then
if true then return _new(DeflateRaw, opts); end;
end
if Zlib:call(this, opts, binding.DEFLATERAW) then end;
end);
InflateRaw = (function (this, opts)
local InflateRaw = _debug.getinfo(1, 'f').func;
if (not _truthy(_instanceof(this, InflateRaw))) then
if true then return _new(InflateRaw, opts); end;
end
if Zlib:call(this, opts, binding.INFLATERAW) then end;
end);
Unzip = (function (this, opts)
local Unzip = _debug.getinfo(1, 'f').func;
if (not _truthy(_instanceof(this, Unzip))) then
if true then return _new(Unzip, opts); end;
end
if Zlib:call(this, opts, binding.UNZIP) then end;
end);
Zlib = (function (this, opts, mode)
local Zlib = _debug.getinfo(1, 'f').func;
local self = self;
(this)._opts = (function () local _r = opts or _obj({
  }); opts = _r; return _r; end)();
(this)._chunkSize = (opts).chunkSize or (exports).Z_DEFAULT_CHUNK;
if Transform:call(this, opts) then end;
((this)._readableState).chunkSize = (null);
if _truthy((opts).chunkSize) then
if _truthy(((opts).chunkSize < (exports).Z_MIN_CHUNK) or ((opts).chunkSize > (exports).Z_MAX_CHUNK)) then
_error(_new(Error, (("Invalid chunk size: ") + (opts).chunkSize)))
end
end
if _truthy((opts).windowBits) then
if _truthy(((opts).windowBits < (exports).Z_MIN_WINDOWBITS) or ((opts).windowBits > (exports).Z_MAX_WINDOWBITS)) then
_error(_new(Error, (("Invalid windowBits: ") + (opts).windowBits)))
end
end
if _truthy((opts).level) then
if _truthy(((opts).level < (exports).Z_MIN_LEVEL) or ((opts).level > (exports).Z_MAX_LEVEL)) then
_error(_new(Error, (("Invalid compression level: ") + (opts).level)))
end
end
if _truthy((opts).memLevel) then
if _truthy(((opts).memLevel < (exports).Z_MIN_MEMLEVEL) or ((opts).memLevel > (exports).Z_MAX_MEMLEVEL)) then
_error(_new(Error, (("Invalid memLevel: ") + (opts).memLevel)))
end
end
if _truthy((opts).strategy) then
if _truthy(((opts).strategy ~= (exports).Z_FILTERED) and ((opts).strategy ~= (exports).Z_HUFFMAN_ONLY) and ((opts).strategy ~= (exports).Z_RLE) and ((opts).strategy ~= (exports).Z_FIXED) and ((opts).strategy ~= (exports).Z_DEFAULT_STRATEGY)) then
_error(_new(Error, (("Invalid strategy: ") + (opts).strategy)))
end
end
if _truthy((opts).dictionary) then
if (not _truthy(Buffer:isBuffer(opts.dictionary))) then
_error(_new(Error, ("Invalid dictionary: it should be a Buffer instance")))
end
end
(this)._binding = _new((binding).Zlib, mode);
self = this;
(this)._hadError = (false);
((this)._binding).onerror = (function (this, message, errno)
local __K__error = __K__error;
(self)._binding = (null);
(self)._hadError = (true);
_K_error = _new(Error, message);
(_K_error).errno = errno;
(_K_error).code = ((exports).codes)[errno];
if self:emit(("error"), _K_error) then end;
end);
if (this)._binding:init((opts).windowBits or (exports).Z_DEFAULT_WINDOWBITS, (opts).level or (exports).Z_DEFAULT_COMPRESSION, (opts).memLevel or (exports).Z_DEFAULT_MEMLEVEL, (opts).strategy or (exports).Z_DEFAULT_STRATEGY, opts.dictionary) then end;
(this)._buffer = _new(Buffer, (this)._chunkSize);
(this)._offset = (0);
(this)._closed = (false);
if this:once(("end"), this.close) then end;
end);
Transform = require(global, ("./lib/_stream_transform.js"));
binding = process:binding(("zlib"));
util = require(global, ("util"));
assert = (require(global, ("assert"))).ok;
(binding).Z_MIN_WINDOWBITS = (8);
(binding).Z_MAX_WINDOWBITS = (15);
(binding).Z_DEFAULT_WINDOWBITS = (15);
(binding).Z_MIN_CHUNK = (64);
(binding).Z_MAX_CHUNK = Infinity;
(binding).Z_DEFAULT_CHUNK = ((16) * (1024));
(binding).Z_MIN_MEMLEVEL = (1);
(binding).Z_MAX_MEMLEVEL = (9);
(binding).Z_DEFAULT_MEMLEVEL = (8);
(binding).Z_MIN_LEVEL = (-(1));
(binding).Z_MAX_LEVEL = (9);
(binding).Z_DEFAULT_LEVEL = (binding).Z_DEFAULT_COMPRESSION;
if Object:keys(binding):forEach((function (this, k)
if _truthy(k:match(_regexp("^Z", ""))) then
(exports)[k] = (binding)[k];
end
end)) then end;
(exports).codes = _obj({
  ["Z_OK"]=(binding).Z_OK,
  ["Z_STREAM_END"]=(binding).Z_STREAM_END,
  ["Z_NEED_DICT"]=(binding).Z_NEED_DICT,
  ["Z_ERRNO"]=(binding).Z_ERRNO,
  ["Z_STREAM_ERROR"]=(binding).Z_STREAM_ERROR,
  ["Z_DATA_ERROR"]=(binding).Z_DATA_ERROR,
  ["Z_MEM_ERROR"]=(binding).Z_MEM_ERROR,
  ["Z_BUF_ERROR"]=(binding).Z_BUF_ERROR,
  ["Z_VERSION_ERROR"]=(binding).Z_VERSION_ERROR});
if Object:keys(exports.codes):forEach((function (this, k)
((exports).codes)[((exports).codes)[k]] = k;
end)) then end;
(exports).Deflate = Deflate;
(exports).Inflate = Inflate;
(exports).Gzip = Gzip;
(exports).Gunzip = Gunzip;
(exports).DeflateRaw = DeflateRaw;
(exports).InflateRaw = InflateRaw;
(exports).Unzip = Unzip;
(exports).createDeflate = (function (this, o)
if true then return _new(Deflate, o); end;
end);
(exports).createInflate = (function (this, o)
if true then return _new(Inflate, o); end;
end);
(exports).createDeflateRaw = (function (this, o)
if true then return _new(DeflateRaw, o); end;
end);
(exports).createInflateRaw = (function (this, o)
if true then return _new(InflateRaw, o); end;
end);
(exports).createGzip = (function (this, o)
if true then return _new(Gzip, o); end;
end);
(exports).createGunzip = (function (this, o)
if true then return _new(Gunzip, o); end;
end);
(exports).createUnzip = (function (this, o)
if true then return _new(Unzip, o); end;
end);
(exports).deflate = (function (this, buffer, callback)
if zlibBuffer(global, _new(Deflate), buffer, callback) then end;
end);
(exports).gzip = (function (this, buffer, callback)
if zlibBuffer(global, _new(Gzip), buffer, callback) then end;
end);
(exports).deflateRaw = (function (this, buffer, callback)
if zlibBuffer(global, _new(DeflateRaw), buffer, callback) then end;
end);
(exports).unzip = (function (this, buffer, callback)
if zlibBuffer(global, _new(Unzip), buffer, callback) then end;
end);
(exports).inflate = (function (this, buffer, callback)
if zlibBuffer(global, _new(Inflate), buffer, callback) then end;
end);
(exports).gunzip = (function (this, buffer, callback)
if zlibBuffer(global, _new(Gunzip), buffer, callback) then end;
end);
(exports).inflateRaw = (function (this, buffer, callback)
if zlibBuffer(global, _new(InflateRaw), buffer, callback) then end;
end);
if util:inherits(Zlib, Transform) then end;
((Zlib).prototype).reset = (function () reset = (function (this)
local reset = _debug.getinfo(1, 'f').func;
if true then return (this)._binding:reset(); end;
end); return reset; end)();
((Zlib).prototype)._flush = (function (this, output, callback)
local rs, self = rs, self;
rs = (this)._readableState;
self = this;
if (function () local base, prop = this, "_transform"; return base[prop](base, (null), output, (function (this, er)
if _truthy(er) then
if true then return callback(global, er); end;
end
if _truthy((rs).length and ((rs).length < (rs).lowWaterMark) and (not _truthy((rs).ended)) and (rs).needReadable) then
if self:emit(("readable")) then end;
end
if callback(global) then end;
end)); end)() then end;
end);
((Zlib).prototype).flush = (function (this, callback)
local ws, ts, self = ws, ts, self;
ws = (this)._writableState;
ts = (this)._transformState;
if _truthy((ws).writing) then
(ws).needDrain = (true);
self = this;
if this:once(("drain"), (function (this)
if (function () local base, prop = self, "_flush"; return base[prop](base, ts.output, callback); end)() then end;
end)) then end;
if true then return; end;
end
if (function () local base, prop = this, "_flush"; return base[prop](base, ts.output, callback or (function (this)

end)); end)() then end;
end);
((Zlib).prototype).close = (function (this, callback)
local self = self;
if _truthy(callback) then
if process:nextTick(callback) then end;
end
if _truthy((this)._closed) then
if true then return; end;
end
(this)._closed = (true);
if (this)._binding:close() then end;
self = this;
if process:nextTick((function (this)
if self:emit(("close")) then end;
end)) then end;
end);
((Zlib).prototype)._transform = (function (this, chunk, output, cb)
local flushFlag, ws, ending, last, availInBefore, availOutBefore, inOff, req, self, callback = flushFlag, ws, ending, last, availInBefore, availOutBefore, inOff, req, self, callback;
callback = (function (this, availInAfter, availOutAfter, buffer)
local callback = _debug.getinfo(1, 'f').func;
local have, out, newReq = have, out, newReq;
if _truthy((self)._hadError) then
if true then return; end;
end
have = (availOutBefore - availOutAfter);
if assert(global, (have >= (0)), ("have should not go down")) then end;
if (have > (0)) then
out = (self)._buffer:slice(self._offset, ((self)._offset + have));
(self)._offset = (self)._offset + have;
if output(global, out) then end;
end
if _truthy((availOutAfter == (0)) or ((self)._offset >= (self)._chunkSize)) then
availOutBefore = (self)._chunkSize;
(self)._offset = (0);
(self)._buffer = _new(Buffer, (self)._chunkSize);
end
if (availOutAfter == (0)) then
inOff = inOff + (availInBefore - availInAfter);
availInBefore = availInAfter;
newReq = (self)._binding:write(flushFlag, chunk, inOff, availInBefore, self._buffer, self._offset, self._chunkSize);
(newReq).callback = callback;
(newReq).buffer = chunk;
if true then return; end;
end
if cb(global) then end;
end);
flushFlag = nil;
ws = (this)._writableState;
ending = (ws).ending or (ws).ended;
last = ending and (not _truthy(chunk)) or ((ws).length == (chunk).length);
if _truthy((chunk ~= (null)) and (not _truthy(Buffer:isBuffer(chunk)))) then
if true then return cb(global, _new(Error, ("invalid input"))); end;
end
if _truthy(last) then
flushFlag = (binding).Z_FINISH;
else
if (chunk == (null)) then
flushFlag = (binding).Z_FULL_FLUSH;
else
flushFlag = (binding).Z_NO_FLUSH;
end
end
availInBefore = chunk and (chunk).length;
availOutBefore = ((this)._chunkSize - (this)._offset);
inOff = (0);
req = (this)._binding:write(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
(req).buffer = chunk;
(req).callback = callback;
self = this;
end);
if util:inherits(Deflate, Zlib) then end;
if util:inherits(Inflate, Zlib) then end;
if util:inherits(Gzip, Zlib) then end;
if util:inherits(Gunzip, Zlib) then end;
if util:inherits(DeflateRaw, Zlib) then end;
if util:inherits(InflateRaw, Zlib) then end;
if util:inherits(Unzip, Zlib) then end;

return _module.exports;
end