function (_ENV)
local string, math, print, type, pairs = nil, nil, nil, nil, nil;
local _module = _obj({exports=_obj({})}); local exports, module = _module.exports, _module;

local stream, util, fs, crypto, path, os, assert, StringDecoder, StreamCounter, START, START____BOUNDARY, HEADER____FIELD____START, HEADER____FIELD, HEADER____VALUE____START, HEADER____VALUE, HEADER____VALUE____ALMOST____DONE, HEADERS____ALMOST____DONE, PART____DATA____START, PART____DATA, PART____END, END, LF, CR, SPACE, HYPHEN, COLON, A, Z, CONTENT____TYPE____RE, FILE____EXT____RE, LAST____BOUNDARY____SUFFIX____LEN, Form, flushWriteCbs, getBytesExpected, __K__error, beginFlush, endFlush, maybeClose, handleFile, handleField, clearPartVars, setUpParser, uploadPath, parseFilename, lower = stream, util, fs, crypto, path, os, assert, StringDecoder, StreamCounter, START, START____BOUNDARY, HEADER____FIELD____START, HEADER____FIELD, HEADER____VALUE____START, HEADER____VALUE, HEADER____VALUE____ALMOST____DONE, HEADERS____ALMOST____DONE, PART____DATA____START, PART____DATA, PART____END, END, LF, CR, SPACE, HYPHEN, COLON, A, Z, CONTENT____TYPE____RE, FILE____EXT____RE, LAST____BOUNDARY____SUFFIX____LEN, Form, flushWriteCbs, getBytesExpected, __K__error, beginFlush, endFlush, maybeClose, handleFile, handleField, clearPartVars, setUpParser, uploadPath, parseFilename, lower;
Form = (function (this, options)
local Form = _debug.getinfo(1, 'f').func;
local self = self;
self = this;
if (stream).Writable:call(self) then end;
options = options or _obj({
  });
(self)["error"] = (null);
(self).finished = (false);
(self).autoFields = (not ((not ((options).autoFields))));
(self).autoFiles = (not ((not ((options).autoFields))));
(self).maxFields = (options).maxFields or (1000);
(self).maxFieldsSize = (options).maxFieldsSize or (((2) * (1024)) * (1024));
(self).uploadDir = (options).uploadDir or os:tmpDir();
(self).encoding = (options).encoding or ("utf8");
(self).hash = (options).hash or (false);
(self).bytesReceived = (0);
(self).bytesExpected = (null);
(self).openedFiles = _arr({});
(self).totalFieldSize = (0);
(self).totalFieldCount = (0);
(self).flushing = (0);
(self).backpressure = (false);
(self).writeCbs = _arr({});
if _truthy((options).boundary) then
if setUpParser(global, self, options.boundary) then end;
end
if self:on(("newListener"), (function (this, eventName)
if (eventName == ("file")) then
(self).autoFiles = (true);
else
if (eventName == ("field")) then
(self).autoFields = (true);
end
end
end)) then end;
end);
flushWriteCbs = (function (this, self)
local flushWriteCbs = _debug.getinfo(1, 'f').func;
if (self).writeCbs:forEach((function (this, cb)
if process:nextTick(cb) then end;
end)) then end;
(self).writeCbs = _arr({});
(self).backpressure = (false);
end);
getBytesExpected = (function (this, headers)
local getBytesExpected = _debug.getinfo(1, 'f').func;
local contentLength = contentLength;
contentLength = (headers)[("content-length")];
if _truthy(contentLength) then
if true then return parseInt(global, contentLength, (10)); end;
else
if _truthy(((headers)[("transfer-encoding")] == (null))) then
if true then return (0); end;
else
if true then return (null); end;
end
end
end);
_K_error = (function (this, self, err)
local _K_error = _debug.getinfo(1, 'f').func;
if assert:ok((not ((self)["error"])), err.stack) then end;
(self)["error"] = err;
if self:emit(("error"), err) then end;
if (self).openedFiles:forEach((function (this, file)
if (file).ws:destroy() then end;
if fs:unlink(file.path, (function (this, err)

end)) then end;
end)) then end;
end);
beginFlush = (function (this, self)
local beginFlush = _debug.getinfo(1, 'f').func;
(self).flushing = (self).flushing + (1);
end);
endFlush = (function (this, self)
local endFlush = _debug.getinfo(1, 'f').func;
(self).flushing = (self).flushing - (1);
if maybeClose(global, self) then end;
end);
maybeClose = (function (this, self)
local maybeClose = _debug.getinfo(1, 'f').func;
if _truthy((not ((self).flushing)) and (self).finished and (not ((self)["error"]))) then
if self:emit(("close")) then end;
end
end);
handleFile = (function (this, self, fileStream)
local handleFile = _debug.getinfo(1, 'f').func;
local file, counter, hashWorkaroundStream, hash = file, counter, hashWorkaroundStream, hash;
if beginFlush(global, self) then end;
file = _obj({
  ["originalFilename"]=(fileStream).filename,
  ["path"]=uploadPath(global, self.uploadDir, fileStream.filename),
  ["headers"]=(fileStream).headers});
(file).ws = fs:createWriteStream(file.path);
if (self).openedFiles:push(file) then end;
if fileStream:pipe(file.ws) then end;
counter = _new(StreamCounter);
if fileStream:pipe(counter) then end;
hashWorkaroundStream = nil;
hash = (null);
if _truthy((self).hash) then
hashWorkaroundStream = stream:Writable();
hash = crypto:createHash(self.hash);
(hashWorkaroundStream)._write = (function (this, buffer, encoding, callback)
if hash:update(buffer) then end;
if callback(global) then end;
end);
if fileStream:pipe(hashWorkaroundStream) then end;
end
if (file).ws:on(("error"), (function (this, err)
if _K_error(global, self, err) then end;
end)) then end;
if (file).ws:on(("close"), (function (this)
if _truthy(hash) then
(file).hash = hash:digest(("hex"));
end
(file).size = (counter).bytes;
if self:emit(("file"), fileStream.name, file) then end;
if endFlush(global, self) then end;
end)) then end;
end);
handleField = (function (this, self, fieldStream)
local handleField = _debug.getinfo(1, 'f').func;
local value, decoder = value, decoder;
value = ("");
decoder = _new(StringDecoder, (self).encoding);
if beginFlush(global, self) then end;
if fieldStream:on(("readable"), (function (this)
local buffer = buffer;
buffer = fieldStream:read();
(self).totalFieldSize = (self).totalFieldSize + (buffer).length;
if ((self).totalFieldSize > (self).maxFieldsSize) then
if _K_error(global, self, _new(Error, ((("maxFieldsSize ") + (self).maxFieldsSize) + (" exceeded")))) then end;
if true then return; end;
end
value = value + decoder:write(buffer);
end)) then end;
if fieldStream:on(("end"), (function (this)
if self:emit(("field"), fieldStream.name, value) then end;
if endFlush(global, self) then end;
end)) then end;
end);
clearPartVars = (function (this, self)
local clearPartVars = _debug.getinfo(1, 'f').func;
(self).partHeaders = _obj({
  });
(self).partName = (null);
(self).partFilename = (null);
(self).partTransferEncoding = ("binary");
(self).destStream = (null);
(self).headerFieldDecoder = _new(StringDecoder, (self).encoding);
(self).headerField = ("");
(self).headerValueDecoder = _new(StringDecoder, (self).encoding);
(self).headerValue = ("");
end);
setUpParser = (function (this, self, boundary)
local setUpParser = _debug.getinfo(1, 'f').func;
local i = i;
(self).boundary = _new(Buffer, ((boundary).length + (4)));
if (self).boundary:write(("\r\n--"), (0), ((boundary).length + (4)), ("ascii")) then end;
if (self).boundary:write(boundary, (4), boundary.length, ("ascii")) then end;
(self).lookbehind = _new(Buffer, (((self).boundary).length + (8)));
(self).state = START;
(self).boundaryChars = _obj({
  });
i = (0);
while (i < ((self).boundary).length) do

((self).boundaryChars)[((self).boundary)[i]] = (true);

if (function () local _r = i; i = _r + 1; return _r end)() then end;
end
(self).index = (null);
(self).partBoundaryFlag = (false);
(self).lastBoundaryFlag = (false);
if self:on(("finish"), (function (this)
if _truthy(((self).state == HEADER__FIELD__START) and ((self).index == (0)) or ((self).state == PART__DATA) and ((self).index == ((self).boundary).length)) then
if self:onParsePartEnd() then end;
else
if ((self).state ~= END) then
if _K_error(global, self, _new(Error, ("stream ended unexpectedly"))) then end;
end
end
(self).finished = (true);
if maybeClose(global, self) then end;
end)) then end;
end);
uploadPath = (function (this, baseDir, filename)
local uploadPath = _debug.getinfo(1, 'f').func;
local ext, name = ext, name;
ext = path:extname(filename):replace(FILE__EXT__RE, ("$1"));
name = ((((process).pid + ("-")) +
    ((Math:random() * (4294967296)) + (1)):toString((36))) + ext);
if true then return path:join(baseDir, name); end;
end);
parseFilename = (function (this, headerValue)
local parseFilename = _debug.getinfo(1, 'f').func;
local m, filename = m, filename;
m = headerValue:match(_regexp("\\bfilename=\"(.*?)\"($|; )", "i"));
if (not (m)) then
if true then return; end;
end
filename = (m)[(1)]:substr(((m)[(1)]:lastIndexOf(("\\")) + (1)));
filename = filename:replace(_regexp("%22", "g"), ("\""));
filename = filename:replace(_regexp("&#([\\d]{4});", "g"), (function (this, m, code)
if true then return String:fromCharCode(code); end;
end));
if true then return filename; end;
end);
lower = (function (this, c)
local lower = _debug.getinfo(1, 'f').func;
if true then return _bit.bor(c, (32)); end;
end);
(exports).Form = Form;
stream = require(global, ("readable-stream"));
util = require(global, ("util"));
fs = require(global, ("fs"));
crypto = require(global, ("crypto"));
path = require(global, ("path"));
os = require(global, ("os"));
assert = require(global, ("assert"));
StringDecoder = (require(global, ("string_decoder"))).StringDecoder;
StreamCounter = require(global, ("stream-counter"));
START = (0);
START__BOUNDARY = (1);
HEADER__FIELD__START = (2);
HEADER__FIELD = (3);
HEADER__VALUE__START = (4);
HEADER__VALUE = (5);
HEADER__VALUE__ALMOST__DONE = (6);
HEADERS__ALMOST__DONE = (7);
PART__DATA__START = (8);
PART__DATA = (9);
PART__END = (10);
END = (11);
LF = (10);
CR = (13);
SPACE = (32);
HYPHEN = (45);
COLON = (58);
A = (97);
Z = (122);
CONTENT__TYPE__RE = _regexp("^multipart\\/(form-data|related);\\s+boundary=(?:\"([^\"]+)\"|([^;]+))$", "i");
FILE__EXT__RE = _regexp("(\\.[_\\-a-zA-Z0-9]{0,16}).*", "");
LAST__BOUNDARY__SUFFIX__LEN = (4);
if util:inherits(Form, stream.Writable) then end;
((Form).prototype).parse = (function (this, req, cb)
local self, contentType, m, boundary, fields, files = self, contentType, m, boundary, fields, files;
self = this;
if _truthy(cb) then
(self).autoFields = (true);
(self).autoFiles = (true);
end
if req:on(("error"), (function (this, err)
if _K_error(global, self, err) then end;
end)) then end;
if req:on(("aborted"), (function (this)
if self:emit(("aborted")) then end;
if _K_error(global, self, _new(Error, ("Request aborted"))) then end;
end)) then end;
(self).bytesExpected = getBytesExpected(global, req.headers);
contentType = ((req).headers)[("content-type")];
if (not (contentType)) then
if _K_error(global, self, _new(Error, ("missing content-type header"))) then end;
if true then return; end;
end
m = contentType:match(CONTENT__TYPE__RE);
if (not (m)) then
if _K_error(global, self, _new(Error, (("unrecognized content-type: ") + contentType))) then end;
if true then return; end;
end
boundary = (m)[(2)] or (m)[(3)];
if setUpParser(global, self, boundary) then end;
if req:pipe(self) then end;
if _truthy(cb) then
fields = _obj({
  });
files = _obj({
  });
if self:on(("error"), (function (this, err)
if cb(global, err) then end;
end)) then end;
if self:on(("field"), (function (this, name, value)
(fields)[name] = value;
end)) then end;
if self:on(("file"), (function (this, name, file)
(files)[name] = file;
end)) then end;
if self:on(("close"), (function (this)
if cb(global, (null), fields, files) then end;
end)) then end;
end
end);
((Form).prototype)._write = (function (this, buffer, encoding, cb)
local self, i, len, prevIndex, index, state, lookbehind, boundary, boundaryChars, boundaryLength, boundaryEnd, bufferLength, c, cl, err = self, i, len, prevIndex, index, state, lookbehind, boundary, boundaryChars, boundaryLength, boundaryEnd, bufferLength, c, cl, err;
self = this;
i = (0);
len = (buffer).length;
prevIndex = (self).index;
index = (self).index;
state = (self).state;
lookbehind = (self).lookbehind;
boundary = (self).boundary;
boundaryChars = (self).boundaryChars;
boundaryLength = ((self).boundary).length;
boundaryEnd = (boundaryLength - (1));
bufferLength = (buffer).length;
c = nil;
cl = nil;
(function () local _r = (0); i = _r; return _r; end)()
while (i < len) do

c = (buffer)[i];
repeat
local _0 = START; local _1 = START__BOUNDARY; local _2 = HEADER__FIELD__START; local _3 = HEADER__FIELD; local _4 = HEADER__VALUE__START; local _5 = HEADER__VALUE; local _6 = HEADER__VALUE__ALMOST__DONE; local _7 = HEADERS__ALMOST__DONE; local _8 = PART__DATA__START; local _9 = PART__DATA; local _10 = END; local _11;
local _r = state;
if _r == _0 then
index = (0);
state = START__BOUNDARY;
_r = _1;
end
if _r == _1 then
if (index == (boundaryLength - (2))) then
if (c ~= CR) then
if true then return _K_error(global, self, _new(Error, (("Expected CR Received ") + c))); end;
end
(function () local _r = index; index = _r + 1; return _r end)();
_c = _break; break;
else
if (index == (boundaryLength - (1))) then
if (c ~= LF) then
if true then return _K_error(global, self, _new(Error, (("Expected LF Received ") + c))); end;
end
index = (0);
if self:onParsePartBegin() then end;
state = HEADER__FIELD__START;
_c = _break; break;
end
end
if (c ~= (boundary)[(index+(2))]) then
index = (-(2));
end
if (c == (boundary)[(index+(2))]) then
(function () local _r = index; index = _r + 1; return _r end)();
end
_c = _break; break;
end
if _r == _2 then
state = HEADER__FIELD;
(self).headerFieldMark = i;
index = (0);
_r = _3;
end
if _r == _3 then
if (c == CR) then
(self).headerFieldMark = (null);
state = HEADERS__ALMOST__DONE;
_c = _break; break;
end
(function () local _r = index; index = _r + 1; return _r end)();
if (c == HYPHEN) then
_c = _break; break;
end
if (c == COLON) then
if (index == (1)) then
if _K_error(global, self, _new(Error, ("Empty header field"))) then end;
if true then return; end;
end
if self:onParseHeaderField(buffer:slice(self.headerFieldMark, i)) then end;
(self).headerFieldMark = (null);
state = HEADER__VALUE__START;
_c = _break; break;
end
cl = lower(global, c);
if _truthy((cl < A) or (cl > Z)) then
if _K_error(global, self, _new(Error, (("Expected alphabetic character, received ") + c))) then end;
if true then return; end;
end
_c = _break; break;
end
if _r == _4 then
if (c == SPACE) then
_c = _break; break;
end
(self).headerValueMark = i;
state = HEADER__VALUE;
_r = _5;
end
if _r == _5 then
if (c == CR) then
if self:onParseHeaderValue(buffer:slice(self.headerValueMark, i)) then end;
(self).headerValueMark = (null);
if self:onParseHeaderEnd() then end;
state = HEADER__VALUE__ALMOST__DONE;
end
_c = _break; break;
end
if _r == _6 then
if (c ~= LF) then
if true then return _K_error(global, self, _new(Error, (("Expected LF Received ") + c))); end;
end
state = HEADER__FIELD__START;
_c = _break; break;
end
if _r == _7 then
if (c ~= LF) then
if true then return _K_error(global, self, _new(Error, (("Expected LF Received ") + c))); end;
end
err = self:onParseHeadersEnd((i + (1)));
if _truthy(err) then
if true then return _K_error(global, self, err); end;
end
state = PART__DATA__START;
_c = _break; break;
end
if _r == _8 then
state = PART__DATA;
(self).partDataMark = i;
_r = _9;
end
if _r == _9 then
prevIndex = index;
if (index == (0)) then
i = i + boundaryEnd;
while _truthy((i < bufferLength) and (not (_in((buffer)[i], boundaryChars)))) do

i = i + boundaryLength;

end
i = i - boundaryEnd;
c = (buffer)[i];
end
if (index < boundaryLength) then
if ((boundary)[index] == c) then
if (index == (0)) then
if self:onParsePartData(buffer:slice(self.partDataMark, i)) then end;
(self).partDataMark = (null);
end
(function () local _r = index; index = _r + 1; return _r end)();
else
index = (0);
end
else
if (index == boundaryLength) then
(function () local _r = index; index = _r + 1; return _r end)();
if (c == CR) then
(self).partBoundaryFlag = (true);
else
if (c == HYPHEN) then
(self).lastBoundaryFlag = (true);
else
index = (0);
end
end
else
if ((index - (1)) == boundaryLength) then
if _truthy((self).partBoundaryFlag) then
index = (0);
if (c == LF) then
(self).partBoundaryFlag = (false);
if self:onParsePartEnd() then end;
if self:onParsePartBegin() then end;
state = HEADER__FIELD__START;
_c = _break; break;
end
else
if _truthy((self).lastBoundaryFlag) then
if (c == HYPHEN) then
if self:onParsePartEnd() then end;
if (function () local base, prop = self, "end"; return base[prop](base); end)() then end;
state = END;
else
index = (0);
end
else
index = (0);
end
end
end
end
end
if (index > (0)) then
(lookbehind)[(index-(1))] = c;
else
if (prevIndex > (0)) then
if self:onParsePartData(lookbehind:slice((0), prevIndex)) then end;
prevIndex = (0);
(self).partDataMark = i;
(function () local _r = i; i = _r - 1; return _r end)();
end
end
_c = _break; break;
end
if _r == _10 then
_c = _break; break;
end
if _K_error(global, self, _new(Error, ("Parser has invalid state."))) then end;
if true then return; end;
until true

if (function () local _r = i; i = _r + 1; return _r end)() then end;
end
if ((self).headerFieldMark ~= (null)) then
if self:onParseHeaderField(buffer:slice(self.headerFieldMark)) then end;
(self).headerFieldMark = (0);
end
if ((self).headerValueMark ~= (null)) then
if self:onParseHeaderValue(buffer:slice(self.headerValueMark)) then end;
(self).headerValueMark = (0);
end
if ((self).partDataMark ~= (null)) then
if self:onParsePartData(buffer:slice(self.partDataMark)) then end;
(self).partDataMark = (0);
end
(self).index = index;
(self).state = state;
(self).bytesReceived = (self).bytesReceived + (buffer).length;
if self:emit(("progress"), self.bytesReceived, self.bytesExpected) then end;
if _truthy((self).backpressure) then
if (self).writeCbs:push(cb) then end;
else
if cb(global) then end;
end
end);
((Form).prototype).onParsePartBegin = (function (this)
if clearPartVars(global, this) then end;
end)

;
((Form).prototype).onParseHeaderField = (function (this, b)
(this).headerField = (this).headerField + (this).headerFieldDecoder:write(b);
end)

;
((Form).prototype).onParseHeaderValue = (function (this, b)
(this).headerValue = (this).headerValue + (this).headerValueDecoder:write(b);
end)

;
((Form).prototype).onParseHeaderEnd = (function (this)
local m = m;
(this).headerField = (this).headerField:toLowerCase();
((this).partHeaders)[(this).headerField] = (this).headerValue;
m = nil;
if ((this).headerField == ("content-disposition")) then
if _truthy((function () local _r = (this).headerValue:match(_regexp("\\bname=\"([^\"]+)\"", "i")); m = _r; return _r; end)()) then
(this).partName = (m)[(1)];
end
(this).partFilename = parseFilename(global, this.headerValue);
else
if ((this).headerField == ("content-transfer-encoding")) then
(this).partTransferEncoding = (this).headerValue:toLowerCase();
end
end
(this).headerFieldDecoder = _new(StringDecoder, (this).encoding);
(this).headerField = ("");
(this).headerValueDecoder = _new(StringDecoder, (this).encoding);
(this).headerValue = ("");
end)

;
((Form).prototype).onParsePartData = (function (this, b)
if ((this).partTransferEncoding == ("base64")) then
(this).backpressure = (not ((this).destStream:write(b:toString(("ascii")), ("base64"))));
else
(this).backpressure = (not ((this).destStream:write(b)));
end
end)

;
((Form).prototype).onParsePartEnd = (function (this)
local s = s;
if _truthy((this).destStream) then
if flushWriteCbs(global, this) then end;
s = (this).destStream;
if process:nextTick((function (this)
if (function () local base, prop = s, "end"; return base[prop](base); end)() then end;
end)) then end;
end
if clearPartVars(global, this) then end;
end)

;
((Form).prototype).onParseHeadersEnd = (function (this, offset)
local self, partContentLength = self, partContentLength;
self = this;
repeat
local _0 = ("binary"); local _1 = ("7bit"); local _2 = ("8bit"); local _3 = ("base64"); local _4;
local _r = (self).partTransferEncoding;
if _r == _0 then

_r = _1;
end
if _r == _1 then

_r = _2;
end
if _r == _2 then
(self).partTransferEncoding = ("binary");
_c = _break; break;
end
if _r == _3 then
_c = _break; break;
end
if true then return _new(Error, (("unknown transfer-encoding: ") + (self).partTransferEncoding)); end;
until true
(self).destStream = _new((stream).PassThrough);
if (self).destStream:on(("drain"), (function (this)
if flushWriteCbs(global, self) then end;
end)) then end;
((self).destStream).headers = (self).partHeaders;
((self).destStream).name = (self).partName;
((self).destStream).filename = (self).partFilename;
((self).destStream).byteOffset = ((self).bytesReceived + offset);
partContentLength = (((self).destStream).headers)[("content-length")];
((self).destStream).byteCount = (_truthy(partContentLength) and {parseInt(global, partContentLength, (10))} or {((((self).bytesExpected - ((self).destStream).byteOffset) -
     ((self).boundary).length) - LAST__BOUNDARY__SUFFIX__LEN)})[1];
(self).totalFieldCount = (self).totalFieldCount + (1);
if ((self).totalFieldCount >= (self).maxFields) then
if _K_error(global, self, _new(Error, ((("maxFields ") + (self).maxFields) + (" exceeded.")))) then end;
if true then return; end;
end
if self:emit(("part"), self.destStream) then end;
if _truthy((((self).destStream).filename == (null)) and (self).autoFields) then
if handleField(global, self, self.destStream) then end;
else
if _truthy((((self).destStream).filename ~= (null)) and (self).autoFiles) then
if handleFile(global, self, self.destStream) then end;
end
end
end)

;

return _module.exports;
end