-- Copyright Joyent, Inc. and other Node contributors.
--
-- Permission is hereby granted, free of charge, to any person obtaining a
-- copy of this software and associated documentation files (the
-- "Software"), to deal in the Software without restriction, including
-- without limitation the rights to use, copy, modify, merge, publish,
-- distribute, sublicense, and/or sell copies of the Software, and to permit
-- persons to whom the Software is furnished to do so, subject to the
-- following conditions:
--
-- The above copyright notice and this permission notice shall be included
-- in all copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-- OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-- MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
-- NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
-- DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
-- OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
-- USE OR OTHER DEALINGS IN THE SOFTWARE.

function (_ENV)
local string, math, print, type, pairs = nil, nil, nil, nil, nil;
local _module = _obj({exports=_obj({})}); local exports, module = _module.exports, _module;

local EE, Stream, util, StringDecoder, ReadableState, Readable, readableAddChunk, needMoreData, MAX____HWM, roundUpToNextPowerOf2, howMuchToRead, chunkInvalid, onEofChunk, emitReadable, emitReadable____, maybeReadMore, maybeReadMore____, pipeOnDrain, flow, pipeOnReadable, emitDataEvents, fromList, endReadable = EE, Stream, util, StringDecoder, ReadableState, Readable, readableAddChunk, needMoreData, MAX____HWM, roundUpToNextPowerOf2, howMuchToRead, chunkInvalid, onEofChunk, emitReadable, emitReadable____, maybeReadMore, maybeReadMore____, pipeOnDrain, flow, pipeOnReadable, emitDataEvents, fromList, endReadable;
ReadableState = (function (this, options, stream)
local ReadableState = _debug.getinfo(1, 'f').func;
local hwm = hwm;
options = options or _obj({
  });
hwm = (options).highWaterMark;
(this).highWaterMark = (_truthy(hwm or (hwm == (0))) and {hwm} or {((16) * (1024))})[1];
(this).highWaterMark = _bit.bnot(_bit.bnot((this).highWaterMark));
(this).buffer = _arr({});
(this).length = (0);
(this).pipes = (null);
(this).pipesCount = (0);
(this).flowing = (false);
(this).ended = (false);
(this).endEmitted = (false);
(this).reading = (false);
(this).calledRead = (false);
(this).sync = (true);
(this).needReadable = (false);
(this).emittedReadable = (false);
(this).readableListening = (false);
(this).objectMode = (not ((not ((options).objectMode))));
(this).defaultEncoding = (options).defaultEncoding or ("utf8");
(this).ranOut = (false);
(this).awaitDrain = (0);
(this).readingMore = (false);
(this).decoder = (null);
(this).encoding = (null);
if _truthy((options).encoding) then
if (not (StringDecoder)) then
StringDecoder = (require(global, ("string_decoder"))).StringDecoder;
end
(this).decoder = _new(StringDecoder, (options).encoding);
(this).encoding = (options).encoding;
end
end);
Readable = (function (this, options)
local Readable = _debug.getinfo(1, 'f').func;
if (not (_instanceof(this, Readable))) then
if true then return _new(Readable, options); end;
end
(this)._readableState = _new(ReadableState, options, this);
(this).readable = (true);
if Stream:call(this) then end;
end);
readableAddChunk = (function (this, stream, state, chunk, encoding, addToFront)
local readableAddChunk = _debug.getinfo(1, 'f').func;
local er, e = er, e;
er = chunkInvalid(global, state, chunk);
if _truthy(er) then
if stream:emit(("error"), er) then end;
else
if _truthy((chunk == (null)) or (chunk == undefined)) then
(state).reading = (false);
if (not ((state).ended)) then
if onEofChunk(global, stream, state) then end;
end
else
if _truthy((state).objectMode or chunk and ((chunk).length > (0))) then
if _truthy((state).ended and (not (addToFront))) then
e = _new(Error, ("stream.push() after EOF"));
if stream:emit(("error"), e) then end;
else
if _truthy((state).endEmitted and addToFront) then
e = _new(Error, ("stream.unshift() after end event"));
if stream:emit(("error"), e) then end;
else
if _truthy((state).decoder and (not (addToFront)) and (not (encoding))) then
chunk = (state).decoder:write(chunk);
end
(state).length = (state).length + (_truthy((state).objectMode) and {(1)} or {(chunk).length})[1];
if _truthy(addToFront) then
if (state).buffer:unshift(chunk) then end;
else
(state).reading = (false);
if (state).buffer:push(chunk) then end;
end
if _truthy((state).needReadable) then
if emitReadable(global, stream) then end;
end
if maybeReadMore(global, stream, state) then end;
end
end
else
if (not (addToFront)) then
(state).reading = (false);
end
end
end
end
if true then return needMoreData(global, state); end;
end);
needMoreData = (function (this, state)
local needMoreData = _debug.getinfo(1, 'f').func;
if true then return (not ((state).ended)) and (state).needReadable or ((state).length < (state).highWaterMark) or ((state).length == (0)); end;
end);
roundUpToNextPowerOf2 = (function (this, n)
local roundUpToNextPowerOf2 = _debug.getinfo(1, 'f').func;
local p = p;
if (n >= MAX__HWM) then
n = MAX__HWM;
else
(function () local _r = n; n = _r - 1; return _r end)();
p = (1);
while (p < (32)) do

n = _bit.bor(n, _bit.rshift(n, p));

if (function () local _r = _bit.lshift(p, (1)); p = _r; return _r; end)() then end;
end
(function () local _r = n; n = _r + 1; return _r end)();
end
if true then return n; end;
end);
howMuchToRead = (function (this, n, state)
local howMuchToRead = _debug.getinfo(1, 'f').func;
if _truthy(((state).length == (0)) and (state).ended) then
if true then return (0); end;
end
if _truthy((state).objectMode) then
if true then return ((n == (0)) and {(0)} or {(1)})[1]; end;
end
if _truthy(isNaN(global, n) or (n == (null))) then
if _truthy((state).flowing and ((state).buffer).length) then
if true then return (((state).buffer)[(0)]).length; end;
else
if true then return (state).length; end;
end
end
if (n <= (0)) then
if true then return (0); end;
end
if (n > (state).highWaterMark) then
(state).highWaterMark = roundUpToNextPowerOf2(global, n);
end
if (n > (state).length) then
if (not ((state).ended)) then
(state).needReadable = (true);
if true then return (0); end;
else
if true then return (state).length; end;
end
end
if true then return n; end;
end);
chunkInvalid = (function (this, state, chunk)
local chunkInvalid = _debug.getinfo(1, 'f').func;
local er = er;
er = (null);
if _truthy((not (Buffer:isBuffer(chunk))) and (("string") ~= _typeof(chunk)) and (chunk ~= (null)) and (chunk ~= undefined) and (not ((state).objectMode)) and (not (er))) then
er = _new(TypeError, ("Invalid non-string/buffer chunk"));
end
if true then return er; end;
end);
onEofChunk = (function (this, stream, state)
local onEofChunk = _debug.getinfo(1, 'f').func;
local chunk = chunk;
if _truthy((state).decoder and (not ((state).ended))) then
chunk = (function () local base, prop = (state).decoder, "end"; return base[prop](base); end)();
if _truthy(chunk and (chunk).length) then
if (state).buffer:push(chunk) then end;
(state).length = (state).length + (_truthy((state).objectMode) and {(1)} or {(chunk).length})[1];
end
end
(state).ended = (true);
if ((state).length > (0)) then
if emitReadable(global, stream) then end;
else
if endReadable(global, stream) then end;
end
end);
emitReadable = (function (this, stream)
local emitReadable = _debug.getinfo(1, 'f').func;
local state = state;
state = (stream)._readableState;
(state).needReadable = (false);
if _truthy((state).emittedReadable) then
if true then return; end;
end
(state).emittedReadable = (true);
if _truthy((state).sync) then
if process:nextTick((function (this)
if emitReadable__(global, stream) then end;
end)) then end;
else
if emitReadable__(global, stream) then end;
end
end);
emitReadable__ = (function (this, stream)
local emitReadable__ = _debug.getinfo(1, 'f').func;
if stream:emit(("readable")) then end;
end);
maybeReadMore = (function (this, stream, state)
local maybeReadMore = _debug.getinfo(1, 'f').func;
if (not ((state).readingMore)) then
(state).readingMore = (true);
if process:nextTick((function (this)
if maybeReadMore__(global, stream, state) then end;
end)) then end;
end
end);
maybeReadMore__ = (function (this, stream, state)
local maybeReadMore__ = _debug.getinfo(1, 'f').func;
local len = len;
len = (state).length;
while _truthy((not ((state).reading)) and (not ((state).flowing)) and (not ((state).ended)) and ((state).length < (state).highWaterMark)) do

if stream:read((0)) then end;
if (len == (state).length) then
_c = _break; break;
else
len = (state).length;
end

end
(state).readingMore = (false);
end);
pipeOnDrain = (function (this, src)
local pipeOnDrain = _debug.getinfo(1, 'f').func;
if true then return (function (this)
local dest, state = dest, state;
dest = this;
state = (src)._readableState;
(function () local _r = (state).awaitDrain; (state).awaitDrain = _r - 1; return _r end)();
if ((state).awaitDrain == (0)) then
if flow(global, src) then end;
end
end); end;
end);
flow = (function (this, src)
local flow = _debug.getinfo(1, 'f').func;
local state, chunk, write = state, chunk, write;
write = (function (this, dest, i, list)
local write = _debug.getinfo(1, 'f').func;
local written = written;
written = dest:write(chunk);
if ((false) == written) then
(function () local _r = (state).awaitDrain; (state).awaitDrain = _r + 1; return _r end)();
end
end);
state = (src)._readableState;
chunk = nil;
(state).awaitDrain = (0);
while _truthy((state).pipesCount and ((null) ~= (function () local _r = src:read(); chunk = _r; return _r; end)())) do

if ((state).pipesCount == (1)) then
if write(global, state.pipes, (0), (null)) then end;
else
if (state).pipes:forEach(write) then end;
end
if src:emit(("data"), chunk) then end;
if ((state).awaitDrain > (0)) then
if true then return; end;
end

end
if ((state).pipesCount == (0)) then
(state).flowing = (false);
if (EE:listenerCount(src, ("data")) > (0)) then
if emitDataEvents(global, src) then end;
end
if true then return; end;
end
(state).ranOut = (true);
end);
pipeOnReadable = (function (this)
local pipeOnReadable = _debug.getinfo(1, 'f').func;
if _truthy(((this)._readableState).ranOut) then
((this)._readableState).ranOut = (false);
if flow(global, this) then end;
end
end);
emitDataEvents = (function (this, stream, startPaused)
local emitDataEvents = _debug.getinfo(1, 'f').func;
local state, paused, readable = state, paused, readable;
state = (stream)._readableState;
if _truthy((state).flowing) then
_error(_new(Error, ("Cannot switch to old mode now.")))
end
paused = startPaused or (false);
readable = (false);
(stream).readable = (true);
(stream).pipe = ((Stream).prototype).pipe;
(stream).on = (function () local _r = ((Stream).prototype).on; (stream).addListener = _r; return _r; end)();
if stream:on(("readable"), (function (this)
local c = c;
readable = (true);
c = nil;
while _truthy((not (paused)) and ((null) ~= (function () local _r = stream:read(); c = _r; return _r; end)())) do

if stream:emit(("data"), c) then end;

end
if (c == (null)) then
readable = (false);
((stream)._readableState).needReadable = (true);
end
end)) then end;
(stream).pause = (function (this)
paused = (true);
if this:emit(("pause")) then end;
end);
(stream).resume = (function (this)
paused = (false);
if _truthy(readable) then
if process:nextTick((function (this)
if stream:emit(("readable")) then end;
end)) then end;
else
if this:read((0)) then end;
end
if this:emit(("resume")) then end;
end);
if stream:emit(("readable")) then end;
end);
fromList = (function (this, n, state)
local fromList = _debug.getinfo(1, 'f').func;
local list, length, stringMode, objectMode, ret, buf, c, i, l, cpy = list, length, stringMode, objectMode, ret, buf, c, i, l, cpy;
list = (state).buffer;
length = (state).length;
stringMode = (not ((not ((state).decoder))));
objectMode = (not ((not ((state).objectMode))));
ret = nil;
if ((list).length == (0)) then
if true then return (null); end;
end
if (length == (0)) then
ret = (null);
else
if _truthy(objectMode) then
ret = list:shift();
else
if _truthy((not (n)) or (n >= length)) then
if _truthy(stringMode) then
ret = list:join((""));
else
ret = Buffer:concat(list, length);
end
(list).length = (0);
else
if (n < ((list)[(0)]).length) then
buf = (list)[(0)];
ret = buf:slice((0), n);
(list)[(0)] = buf:slice(n);
else
if (n == ((list)[(0)]).length) then
ret = list:shift();
else
if _truthy(stringMode) then
ret = ("");
else
ret = _new(Buffer, n);
end
c = (0);
i = (0);
l = (list).length;
while _truthy((i < l) and (c < n)) do

buf = (list)[(0)];
cpy = Math:min((n - c), buf.length);
if _truthy(stringMode) then
ret = ret + buf:slice((0), cpy);
else
if buf:copy(ret, c, (0), cpy) then end;
end
if (cpy < (buf).length) then
(list)[(0)] = buf:slice(cpy);
else
if list:shift() then end;
end
c = c + cpy;

if (function () local _r = i; i = _r + 1; return _r end)() then end;
end
end
end
end
end
end
if true then return ret; end;
end);
endReadable = (function (this, stream)
local endReadable = _debug.getinfo(1, 'f').func;
local state = state;
state = (stream)._readableState;
if ((state).length > (0)) then
_error(_new(Error, ("endReadable called on non-empty stream")))
end
if _truthy((not ((state).endEmitted)) and (state).calledRead) then
(state).ended = (true);
if process:nextTick((function (this)
if _truthy((not ((state).endEmitted)) and ((state).length == (0))) then
(state).endEmitted = (true);
(stream).readable = (false);
if stream:emit(("end")) then end;
end
end)) then end;
end
end);
(module).exports = Readable;
(Readable).ReadableState = ReadableState;
EE = (require(global, ("events"))).EventEmitter;
if (not ((EE).listenerCount)) then
(EE).listenerCount = (function (this, emitter, type)
if true then return (emitter:listeners(type)).length; end;
end);
end
Stream = require(global, ("stream"));
util = require(global, ("util"));
StringDecoder = nil;
if util:inherits(Readable, Stream) then end;
((Readable).prototype).push = (function (this, chunk, encoding)
local state = state;
state = (this)._readableState;
if _truthy((_typeof(chunk) == ("string")) and (not ((state).objectMode))) then
encoding = encoding or (state).defaultEncoding;
if (encoding ~= (state).encoding) then
chunk = _new(Buffer, chunk, encoding);
encoding = ("");
end
end
if true then return readableAddChunk(global, this, state, chunk, encoding, (false)); end;
end);
((Readable).prototype).unshift = (function (this, chunk)
local state = state;
state = (this)._readableState;
if true then return readableAddChunk(global, this, state, chunk, (""), (true)); end;
end);
((Readable).prototype).setEncoding = (function (this, enc)
if (not (StringDecoder)) then
StringDecoder = (require(global, ("string_decoder"))).StringDecoder;
end
((this)._readableState).decoder = _new(StringDecoder, enc);
((this)._readableState).encoding = enc;
end);
MAX__HWM = (8388608);
((Readable).prototype).read = (function (this, n)
local state, nOrig, doRead, ret = state, nOrig, doRead, ret;
state = (this)._readableState;
(state).calledRead = (true);
nOrig = n;
if _truthy((_typeof(n) ~= ("number")) or (n > (0))) then
(state).emittedReadable = (false);
end
if _truthy((n == (0)) and (state).needReadable and ((state).length >= (state).highWaterMark) or (state).ended) then
if emitReadable(global, this) then end;
if true then return (null); end;
end
n = howMuchToRead(global, n, state);
if _truthy((n == (0)) and (state).ended) then
if ((state).length == (0)) then
if endReadable(global, this) then end;
end
if true then return (null); end;
end
doRead = (state).needReadable;
if (((state).length - n) <= (state).highWaterMark) then
doRead = (true);
end
if _truthy((state).ended or (state).reading) then
doRead = (false);
end
if _truthy(doRead) then
(state).reading = (true);
(state).sync = (true);
if ((state).length == (0)) then
(state).needReadable = (true);
end
if (function () local base, prop = this, "_read"; return base[prop](base, state.highWaterMark); end)() then end;
(state).sync = (false);
end
if _truthy(doRead and (not ((state).reading))) then
n = howMuchToRead(global, nOrig, state);
end
ret = nil;
if (n > (0)) then
ret = fromList(global, n, state);
else
ret = (null);
end
if (ret == (null)) then
(state).needReadable = (true);
n = (0);
end
(state).length = (state).length - n;
if _truthy(((state).length == (0)) and (not ((state).ended))) then
(state).needReadable = (true);
end
if _truthy((state).ended and (not ((state).endEmitted)) and ((state).length == (0))) then
if endReadable(global, this) then end;
end
if true then return ret; end;
end);
((Readable).prototype)._read = (function (this, n)
if this:emit(("error"), _new(Error, ("not implemented"))) then end;
end);
((Readable).prototype).pipe = (function (this, dest, pipeOpts)
local src, state, doEnd, endFn, onunpipe, onend, ondrain, cleanup, onerror, onclose, onfinish, unpipe = src, state, doEnd, endFn, onunpipe, onend, ondrain, cleanup, onerror, onclose, onfinish, unpipe;
onunpipe = (function (this, readable)
local onunpipe = _debug.getinfo(1, 'f').func;
if (readable ~= src) then
if true then return; end;
end
if cleanup(global) then end;
end);
onend = (function (this)
local onend = _debug.getinfo(1, 'f').func;
if (function () local base, prop = dest, "end"; return base[prop](base); end)() then end;
end);
cleanup = (function (this)
local cleanup = _debug.getinfo(1, 'f').func;
if dest:removeListener(("close"), onclose) then end;
if dest:removeListener(("finish"), onfinish) then end;
if dest:removeListener(("drain"), ondrain) then end;
if dest:removeListener(("error"), onerror) then end;
if dest:removeListener(("unpipe"), onunpipe) then end;
if src:removeListener(("end"), onend) then end;
if src:removeListener(("end"), cleanup) then end;
if _truthy((not ((dest)._writableState)) or ((dest)._writableState).needDrain) then
if ondrain(global) then end;
end
end);
onerror = (function (this, er)
local onerror = _debug.getinfo(1, 'f').func;
if unpipe(global) then end;
if dest:removeListener(("error"), onerror) then end;
if (EE:listenerCount(dest, ("error")) == (0)) then
if dest:emit(("error"), er) then end;
end
end);
onclose = (function (this)
local onclose = _debug.getinfo(1, 'f').func;
if dest:removeListener(("finish"), onfinish) then end;
if unpipe(global) then end;
end);
onfinish = (function (this)
local onfinish = _debug.getinfo(1, 'f').func;
if dest:removeListener(("close"), onclose) then end;
if unpipe(global) then end;
end);
unpipe = (function (this)
local unpipe = _debug.getinfo(1, 'f').func;
if src:unpipe(dest) then end;
end);
src = this;
state = (this)._readableState;
repeat
local _0 = (0); local _1 = (1); local _2;
local _r = (state).pipesCount;
if _r == _0 then
(state).pipes = dest;
_c = _break; break;
end
if _r == _1 then
(state).pipes = _arr({[0]=(state).pipes, dest});
_c = _break; break;
end
if (state).pipes:push(dest) then end;
_c = _break; break;
until true
(state).pipesCount = (state).pipesCount + (1);
doEnd = (not (pipeOpts)) or ((pipeOpts)["end"] ~= (false)) and (dest ~= (process).stdout) and (dest ~= (process).stderr);
endFn = (_truthy(doEnd) and {onend} or {cleanup})[1];
if _truthy((state).endEmitted) then
if process:nextTick(endFn) then end;
else
if src:once(("end"), endFn) then end;
end
if dest:on(("unpipe"), onunpipe) then end;
ondrain = pipeOnDrain(global, src);
if dest:on(("drain"), ondrain) then end;
if (not (((dest)._events)["error"])) then
if dest:on(("error"), onerror) then end;
else
if _truthy(Array:isArray((dest)._events.error)) then
if ((dest)._events)["error"]:unshift(onerror) then end;
else
((dest)._events)["error"] = _arr({[0]=onerror, ((dest)._events)["error"]});
end
end
if dest:once(("close"), onclose) then end;
if dest:once(("finish"), onfinish) then end;
if dest:emit(("pipe"), src) then end;
if (not ((state).flowing)) then
if this:on(("readable"), pipeOnReadable) then end;
(state).flowing = (true);
if process:nextTick((function (this)
if flow(global, src) then end;
end)) then end;
end
if true then return dest; end;
end);
((Readable).prototype).unpipe = (function (this, dest)
local state, dests, len, i = state, dests, len, i;
state = (this)._readableState;
if ((state).pipesCount == (0)) then
if true then return this; end;
end
if ((state).pipesCount == (1)) then
if _truthy(dest and (dest ~= (state).pipes)) then
if true then return this; end;
end
if (not (dest)) then
dest = (state).pipes;
end
(state).pipes = (null);
(state).pipesCount = (0);
if this:removeListener(("readable"), pipeOnReadable) then end;
(state).flowing = (false);
if _truthy(dest) then
if dest:emit(("unpipe"), this) then end;
end
if true then return this; end;
end
if (not (dest)) then
dests = (state).pipes;
len = (state).pipesCount;
(state).pipes = (null);
(state).pipesCount = (0);
if this:removeListener(("readable"), pipeOnReadable) then end;
(state).flowing = (false);
i = (0);
while (i < len) do

if (dests)[i]:emit(("unpipe"), this) then end;

if (function () local _r = i; i = _r + 1; return _r end)() then end;
end
if true then return this; end;
end
i = (state).pipes:indexOf(dest);
if (i == (-(1))) then
if true then return this; end;
end
if (state).pipes:splice(i, (1)) then end;
(state).pipesCount = (state).pipesCount - (1);
if ((state).pipesCount == (1)) then
(state).pipes = ((state).pipes)[(0)];
end
if dest:emit(("unpipe"), this) then end;
if true then return this; end;
end);
((Readable).prototype).on = (function (this, ev, fn)
local res, state = res, state;
res = ((Stream).prototype).on:call(this, ev, fn);
if _truthy((ev == ("data")) and (not (((this)._readableState).flowing))) then
if emitDataEvents(global, this) then end;
end
if _truthy((ev == ("readable")) and (this).readable) then
state = (this)._readableState;
if (not ((state).readableListening)) then
(state).readableListening = (true);
(state).emittedReadable = (false);
(state).needReadable = (true);
if (not ((state).reading)) then
if this:read((0)) then end;
else
if _truthy((state).length) then
if emitReadable(global, this, state) then end;
end
end
end
end
if true then return res; end;
end);
((Readable).prototype).addListener = ((Readable).prototype).on;
((Readable).prototype).resume = (function (this)
if emitDataEvents(global, this) then end;
if this:read((0)) then end;
if this:emit(("resume")) then end;
end);
((Readable).prototype).pause = (function (this)
if emitDataEvents(global, this, (true)) then end;
if this:emit(("pause")) then end;
end);
((Readable).prototype).wrap = (function (this, stream)
local state, paused, self, i, events = state, paused, self, i, events;
state = (this)._readableState;
paused = (false);
self = this;
if stream:on(("end"), (function (this)
local chunk = chunk;
if _truthy((state).decoder and (not ((state).ended))) then
chunk = (function () local base, prop = (state).decoder, "end"; return base[prop](base); end)();
if _truthy(chunk and (chunk).length) then
if self:push(chunk) then end;
end
end
if self:push((null)) then end;
end)) then end;
if stream:on(("data"), (function (this, chunk)
local ret = ret;
if _truthy((state).decoder) then
chunk = (state).decoder:write(chunk);
end
if _truthy((not (chunk)) or (not ((state).objectMode)) and (not ((chunk).length))) then
if true then return; end;
end
ret = self:push(chunk);
if (not (ret)) then
paused = (true);
if stream:pause() then end;
end
end)) then end;
for i in _pairs(stream) do
if _truthy((_typeof((stream)[i]) == ("function")) and (_typeof((this)[i]) == ("undefined"))) then
(this)[i] = (function (this, method)
if true then return (function (this, ...)
local arguments = _arguments(...);
if true then return (stream)[method]:apply(stream, arguments); end;
end); end;
end)(global, i);
end
end
events = _arr({[0]=("error"), ("close"), ("destroy"), ("pause"), ("resume")});
if events:forEach((function (this, ev)
if stream:on(ev, (self).emit:bind(self, ev)) then end;
end)) then end;
(self)._read = (function (this, n)
if _truthy(paused) then
paused = (false);
if stream:resume() then end;
end
end);
if true then return self; end;
end);
(Readable)._fromList = fromList;

return _module.exports;
end