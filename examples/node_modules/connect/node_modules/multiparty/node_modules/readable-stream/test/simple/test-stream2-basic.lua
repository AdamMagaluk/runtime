-- Copyright Joyent, Inc. and other Node contributors.
--
-- Permission is hereby granted, free of charge, to any person obtaining a
-- copy of this software and associated documentation files (the
-- "Software"), to deal in the Software without restriction, including
-- without limitation the rights to use, copy, modify, merge, publish,
-- distribute, sublicense, and/or sell copies of the Software, and to permit
-- persons to whom the Software is furnished to do so, subject to the
-- following conditions:
--
-- The above copyright notice and this permission notice shall be included
-- in all copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-- OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-- MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
-- NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
-- DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
-- OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
-- USE OR OTHER DEALINGS IN THE SOFTWARE.


function (_ENV)
local string, math, print, type, pairs = nil, nil, nil, nil, nil;
local _module = _obj({exports=_obj({})}); local exports, module = _module.exports, _module;

local common, R, assert, util, EE, TestReader, TestWriter, tests, count, test, run = common, R, assert, util, EE, TestReader, TestWriter, tests, count, test, run;
TestReader = (function (this, n)
local TestReader = _debug.getinfo(1, 'f').func;
if R:apply(this) then end;
(this)._buffer = _new(Buffer, n or (100));
if (this)._buffer:fill(("x")) then end;
(this)._pos = (0);
(this)._bufs = (10);
end);
TestWriter = (function (this)
local TestWriter = _debug.getinfo(1, 'f').func;
if EE:apply(this) then end;
(this).received = _arr({});
(this).flush = (false);
end);
test = (function (this, name, fn)
local test = _debug.getinfo(1, 'f').func;
(function () local _r = count; count = _r + 1; return _r end)();
if tests:push(_arr({[0]=name, fn})) then end;
end);
run = (function (this)
local run = _debug.getinfo(1, 'f').func;
local next, name, fn = next, name, fn;
next = tests:shift();
if (not (next)) then
if true then return (function () local base, prop = console, "error"; return base[prop](base, ("ok")); end)(); end;
end
name = (next)[(0)];
fn = (next)[(1)];
if console:log(("# %s"), name) then end;
if fn(global, _obj({
  ["same"]=(assert).deepEqual,
  ["ok"]=assert,
  ["equal"]=(assert).equal,
  ["end"]=(function (this)
(function () local _r = count; count = _r - 1; return _r end)();
if run(global) then end;
end)})) then end;
end);
common = require(global, ("../common.js"));
R = require(global, ("../../lib/_stream_readable"));
assert = require(global, ("assert"));
util = require(global, ("util"));
EE = (require(global, ("events"))).EventEmitter;
if util:inherits(TestReader, R) then end;
((TestReader).prototype).read = (function (this, n)
local max, toRead, ret = max, toRead, ret;
if (n == (0)) then
if true then return (null); end;
end
max = (((this)._buffer).length - (this)._pos);
n = n or max;
n = Math:max(n, (0));
toRead = Math:min(n, max);
if (toRead == (0)) then
if setTimeout(global, (function (this)
(this)._pos = (0);
(this)._bufs = (this)._bufs - (1);
if ((this)._bufs <= (0)) then
if (not ((this).ended)) then
if this:emit(("end")) then end;
(this).ended = (true);
end
else
if this:emit(("readable")) then end;
end
end):bind(this), (10)) then end;
if true then return (null); end;
end
ret = (this)._buffer:slice(this._pos, ((this)._pos + toRead));
(this)._pos = (this)._pos + toRead;
if true then return ret; end;
end);
if util:inherits(TestWriter, EE) then end;
((TestWriter).prototype).write = (function (this, c)
if (this).received:push(c:toString()) then end;
if this:emit(("write"), c) then end;
if true then return (true); end;
end);
((TestWriter).prototype)["end"] = (function (this, c)
if _truthy(c) then
if this:write(c) then end;
end
if this:emit(("end"), this.received) then end;
end);
tests = _arr({});
count = (0);
if process:on(("exit"), (function (this)
if assert:equal(count, (0)) then end;
end)) then end;
if process:nextTick(run) then end;
if test(global, ("a most basic test"), (function (this, t)
local r, reads, expect, readSize, flow = r, reads, expect, readSize, flow;
flow = (function (this)
local flow = _debug.getinfo(1, 'f').func;
local res = res;
res = nil;
while ((null) ~= (function () local _r = r:read((function () local _r = readSize; readSize = _r + 1; return _r end)()); res = _r; return _r; end)()) do

if reads:push(res:toString()) then end;

end
if r:once(("readable"), flow) then end;
end);
r = _new(TestReader, (20));
reads = _arr({});
expect = _arr({[0]=("x"), ("xx"), ("xxx"), ("xxxx"), ("xxxxx"), ("xxxxx"), ("xxxxxxxx"), ("xxxxxxxxx"), ("xxx"), ("xxxxxxxxxxxx"), ("xxxxxxxx"), ("xxxxxxxxxxxxxxx"), ("xxxxx"), ("xxxxxxxxxxxxxxxxxx"), ("xx"), ("xxxxxxxxxxxxxxxxxxxx"), ("xxxxxxxxxxxxxxxxxxxx"), ("xxxxxxxxxxxxxxxxxxxx"), ("xxxxxxxxxxxxxxxxxxxx"), ("xxxxxxxxxxxxxxxxxxxx")});
if r:on(("end"), (function (this)
if t:same(reads, expect) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end)) then end;
readSize = (1);
if flow(global) then end;
end)) then end;
if test(global, ("pipe"), (function (this, t)
local r, expect, w, flush = r, expect, w, flush;
r = _new(TestReader, (5));
expect = _arr({[0]=("xxxxx"), ("xxxxx"), ("xxxxx"), ("xxxxx"), ("xxxxx"), ("xxxxx"), ("xxxxx"), ("xxxxx"), ("xxxxx"), ("xxxxx")});
w = _new(TestWriter);
flush = (true);
if w:on(("end"), (function (this, received)
if t:same(received, expect) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end)) then end;
if r:pipe(w) then end;
end)) then end;
if _arr({[0]=(1), (2), (3), (4), (5), (6), (7), (8), (9)}):forEach((function (this, SPLIT)
if test(global, ("unpipe"), (function (this, t)
local r, expect, w, writes, ended, ended0, ended1 = r, expect, w, writes, ended, ended0, ended1;
r = _new(TestReader, (5));
expect = _arr({[0]=("xxxxx"), ("xxxxx"), ("xxxxx"), ("xxxxx"), ("xxxxx"), ("xxxxx"), ("xxxxx"), ("xxxxx"), ("xxxxx"), ("xxxxx")});
expect = _arr({[0]=expect:slice((0), SPLIT), expect:slice(SPLIT)});
w = _arr({[0]=_new(TestWriter), _new(TestWriter)});
writes = SPLIT;
if (w)[(0)]:on(("write"), (function (this)
if ((function () writes = writes - 1; return writes; end)() == (0)) then
if r:unpipe() then end;
if t:equal((r)._readableState.pipes, (null)) then end;
if (function () local base, prop = (w)[(0)], "end"; return base[prop](base); end)() then end;
if r:pipe(w[(1)]) then end;
if t:equal((r)._readableState.pipes, w[(1)]) then end;
end
end)) then end;
ended = (0);
ended0 = (false);
ended1 = (false);
if (w)[(0)]:on(("end"), (function (this, results)
if t:equal(ended0, (false)) then end;
ended0 = (true);
(function () local _r = ended; ended = _r + 1; return _r end)();
if t:same(results, expect[(0)]) then end;
end)) then end;
if (w)[(1)]:on(("end"), (function (this, results)
if t:equal(ended1, (false)) then end;
ended1 = (true);
(function () local _r = ended; ended = _r + 1; return _r end)();
if t:equal(ended, (2)) then end;
if t:same(results, expect[(1)]) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end)) then end;
if r:pipe(w[(0)]) then end;
end)) then end;
end)) then end;
if test(global, ("multipipe"), (function (this, t)
local r, w, expect, c = r, w, expect, c;
r = _new(TestReader, (5));
w = _arr({[0]=_new(TestWriter), _new(TestWriter)});
expect = _arr({[0]=("xxxxx"), ("xxxxx"), ("xxxxx"), ("xxxxx"), ("xxxxx"), ("xxxxx"), ("xxxxx"), ("xxxxx"), ("xxxxx"), ("xxxxx")});
c = (2);
if (w)[(0)]:on(("end"), (function (this, received)
if t:same(received, expect, ("first")) then end;
if ((function () c = c - 1; return c; end)() == (0)) then
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end
end)) then end;
if (w)[(1)]:on(("end"), (function (this, received)
if t:same(received, expect, ("second")) then end;
if ((function () c = c - 1; return c; end)() == (0)) then
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end
end)) then end;
if r:pipe(w[(0)]) then end;
if r:pipe(w[(1)]) then end;
end)) then end;
if _arr({[0]=(1), (2), (3), (4), (5), (6), (7), (8), (9)}):forEach((function (this, SPLIT)
if test(global, ("multi-unpipe"), (function (this, t)
local r, expect, w, writes, ended = r, expect, w, writes, ended;
r = _new(TestReader, (5));
expect = _arr({[0]=("xxxxx"), ("xxxxx"), ("xxxxx"), ("xxxxx"), ("xxxxx"), ("xxxxx"), ("xxxxx"), ("xxxxx"), ("xxxxx"), ("xxxxx")});
expect = _arr({[0]=expect:slice((0), SPLIT), expect:slice(SPLIT)});
w = _arr({[0]=_new(TestWriter), _new(TestWriter), _new(TestWriter)});
writes = SPLIT;
if (w)[(0)]:on(("write"), (function (this)
if ((function () writes = writes - 1; return writes; end)() == (0)) then
if r:unpipe() then end;
if (function () local base, prop = (w)[(0)], "end"; return base[prop](base); end)() then end;
if r:pipe(w[(1)]) then end;
end
end)) then end;
ended = (0);
if (w)[(0)]:on(("end"), (function (this, results)
(function () local _r = ended; ended = _r + 1; return _r end)();
if t:same(results, expect[(0)]) then end;
end)) then end;
if (w)[(1)]:on(("end"), (function (this, results)
(function () local _r = ended; ended = _r + 1; return _r end)();
if t:equal(ended, (2)) then end;
if t:same(results, expect[(1)]) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end)) then end;
if r:pipe(w[(0)]) then end;
if r:pipe(w[(2)]) then end;
end)) then end;
end)) then end;
if test(global, ("back pressure respected"), (function (this, t)
local noop, r, counter, w1, expected, w2, w3 = noop, r, counter, w1, expected, w2, w3;
noop = (function (this)
local noop = _debug.getinfo(1, 'f').func;

end);
r = _new(R, _obj({
  ["objectMode"]=true}));
(r)._read = noop;
counter = (0);
if r:push(_arr({[0]=("one")})) then end;
if r:push(_arr({[0]=("two")})) then end;
if r:push(_arr({[0]=("three")})) then end;
if r:push(_arr({[0]=("four")})) then end;
if r:push((null)) then end;
w1 = _new(R);
(w1).write = (function (this, chunk)
if assert:equal(chunk[(0)], ("one")) then end;
if w1:emit(("close")) then end;
if process:nextTick((function (this)
if r:pipe(w2) then end;
if r:pipe(w3) then end;
end))
   then end;
end);
(w1)["end"] = noop;
if r:pipe(w1) then end;
expected = _arr({[0]=("two"), ("two"), ("three"), ("three"), ("four"), ("four")});
w2 = _new(R);
(w2).write = (function (this, chunk)
if assert:equal(chunk[(0)], expected:shift()) then end;
if assert:equal(counter, (0)) then end;
(function () local _r = counter; counter = _r + 1; return _r end)();
if ((chunk)[(0)] == ("four")) then
if true then return (true); end;
end
if setTimeout(global, (function (this)
(function () local _r = counter; counter = _r - 1; return _r end)();
if w2:emit(("drain")) then end;
end), (10)) then end;
if true then return (false); end;
end)
  ;
(w2)["end"] = noop;
w3 = _new(R);
(w3).write = (function (this, chunk)
if assert:equal(chunk[(0)], expected:shift()) then end;
if assert:equal(counter, (1)) then end;
(function () local _r = counter; counter = _r + 1; return _r end)();
if ((chunk)[(0)] == ("four")) then
if true then return (true); end;
end
if setTimeout(global, (function (this)
(function () local _r = counter; counter = _r - 1; return _r end)();
if w3:emit(("drain")) then end;
end), (50)) then end;
if true then return (false); end;
end);
(w3)["end"] = (function (this)
if assert:equal(counter, (2)) then end;
if assert:equal(expected.length, (0)) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end);
end)) then end;
if test(global, ("read(0) for ended streams"), (function (this, t)
local r, written, ended, v, w = r, written, ended, v, w;
r = _new(R);
written = (false);
ended = (false);
(r)._read = (function (this, n)

end);
if r:push(_new(Buffer, ("foo"))) then end;
if r:push((null)) then end;
v = r:read((0));
if assert:equal(v, (null)) then end;
w = _new(R);
(w).write = (function (this, buffer)
written = (true);
if assert:equal(ended, (false)) then end;
if assert:equal(buffer:toString(), ("foo"))
   then end;
end);
(w)["end"] = (function (this)
ended = (true);
if assert:equal(written, (true)) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end);
if r:pipe(w) then end;
end))

 then end;
if test(global, ("sync _read ending"), (function (this, t)
local r, called = r, called;
r = _new(R);
called = (false);
(r)._read = (function (this, n)
if r:push((null)) then end;
end);
if r:once(("end"), (function (this)
called = (true);
end))

   then end;
if r:read() then end;
if process:nextTick((function (this)
if assert:equal(called, (true)) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end))
 then end;
end)) then end;
if test(global, ("adding readable triggers data flow"), (function (this, t)
local r, onReadable, readCalled, called = r, onReadable, readCalled, called;
r = _new(R, _obj({
  ["highWaterMark"]=5}));
onReadable = (false);
readCalled = (0);
(r)._read = (function (this, n)
if ((function () local _r = readCalled; readCalled = _r + 1; return _r end)() == (2)) then
if r:push((null)) then end;
else
if r:push(_new(Buffer, ("asdf"))) then end;
end
end);
called = (false);
if r:on(("readable"), (function (this)
onReadable = (true);
if r:read() then end;
end)) then end;
if r:on(("end"), (function (this)
if t:equal(readCalled, (3)) then end;
if t:ok(onReadable) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end)) then end;
end)) then end;

return _module.exports;
end