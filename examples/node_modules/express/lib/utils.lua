function (_ENV)
local string, math, print, type, pairs = nil, nil, nil, nil, nil;
local _module = _obj({exports=_obj({})}); local exports, module = _module.exports, _module;

local mime, crc32, toString, paramsEqual, acceptParams = mime, crc32, toString, paramsEqual, acceptParams;
paramsEqual = (function (this, a, b)
local paramsEqual = _debug.getinfo(1, 'f').func;
if true then return (not (Object:keys(a):some((function (this, k)
if true then return ((a)[k] ~= (b)[k]); end;
end)))); end;
end);
acceptParams = (function (this, str, index)
local acceptParams = _debug.getinfo(1, 'f').func;
local parts, ret, i, pms = parts, ret, i, pms;
parts = str:split(_regexp(" *; *", ""));
ret = _obj({
  ["value"]=(parts)[(0)],
  ["quality"]=1,
  ["params"]=_obj({
  }),
  ["originalIndex"]=index});
i = (1);
while (i < (parts).length) do

pms = (parts)[i]:split(_regexp(" *= *", ""));
if _truthy((("q") == (pms)[(0)])) then
(ret).quality = parseFloat(global, pms[(1)]);
else
((ret).params)[(pms)[(0)]] = (pms)[(1)];
end

if (function () i = i + 1; return i; end)() then end;
end
if true then return ret; end;
end);
mime = (require(global, ("connect"))).mime;
crc32 = require(global, ("buffer-crc32"));
toString = (_obj({
  })).toString;
(exports).etag = (function (this, body)
if true then return ((("\"") + crc32:signed(body)) + ("\"")); end;
end);
(exports).locals = (function (this, obj)
local locals = locals;
locals = (function (this, obj)
local locals = _debug.getinfo(1, 'f').func;
local key = key;
for key in _pairs(obj) do
(locals)[key] = (obj)[key];
end
if true then return obj; end;
end);
if true then return locals; end;
end);
(exports).isAbsolute = (function (this, path)
if _truthy((("/") == (path)[(0)])) then
if true then return (true); end;
end
if _truthy(((":") == (path)[(1)]) and (("\\") == (path)[(2)])) then
if true then return (true); end;
end
if _truthy((("\\\\") == path:substring((0), (2)))) then
if true then return (true); end;
end
end);
(exports).flatten = (function (this, arr, ret)
local ret, len, i = ret, len, i;
ret = ret or _arr({});
len = (arr).length;
i = (0);
while (i < len) do

if _truthy(Array:isArray(arr[i])) then
if exports:flatten(arr[i], ret) then end;
else
if ret:push(arr[i]) then end;
end

if (function () i = i + 1; return i; end)() then end;
end
if true then return ret; end;
end);
(exports).normalizeType = (function (this, type)
if true then return (_truthy(_bit.bnot(type:indexOf(("/")))) and {acceptParams(global, type)} or {_obj({
  ["value"]=mime:lookup(type),
  ["params"]=_obj({
  })})})[1]; end;
end);
(exports).normalizeTypes = (function (this, types)
local ret, i = ret, i;
ret = _arr({});
i = (0);
while (i < (types).length) do

if ret:push(exports:normalizeType(types[i])) then end;

if (function () i = i + 1; return i; end)() then end;
end
if true then return ret; end;
end);
(exports).acceptsArray = (function (this, types, str)
local accepted, normalized, len, i, j, jlen = accepted, normalized, len, i, j, jlen;
if (not (str)) then
if true then return (types)[(0)]; end;
end
accepted = exports:parseAccept(str);
normalized = exports:normalizeTypes(types);
len = (accepted).length;
i = (0);
while (i < len) do

j = (0);
jlen = (types).length;
while (j < jlen) do

if _truthy(exports:accept(normalized[j], accepted[i])) then
if true then return (types)[j]; end;
end

if (function () j = j + 1; return j; end)() then end;
end

if (function () i = i + 1; return i; end)() then end;
end
end);
(exports).accepts = (function (this, type, str)
if _truthy((("string") == _typeof(type))) then
type = type:split(_regexp(" *, *", ""));
end
if true then return exports:acceptsArray(type, str); end;
end);
(exports).accept = (function (this, type, other)
local t = t;
t = (type).value:split(("/"));
if true then return ((t)[(0)] == (other).type) or (("*") == (other).type) and ((t)[(1)] == (other).subtype) or (("*") == (other).subtype) and paramsEqual(global, type.params, other.params); end;
end);
(exports).parseAccept = (function (this, str)
if true then return exports:parseParams(str):map((function (this, obj)
local parts = parts;
parts = (obj).value:split(("/"));
(obj).type = (parts)[(0)];
(obj).subtype = (parts)[(1)];
if true then return obj; end;
end)); end;
end);
(exports).parseParams = (function (this, str)
if true then return str:split(_regexp(" *, *", "")):map(acceptParams):filter((function (this, obj)
if true then return (obj).quality; end;
end)):sort((function (this, a, b)
if ((a).quality == (b).quality) then
if true then return ((a).originalIndex - (b).originalIndex); end;
else
if true then return ((b).quality - (a).quality); end;
end
end)); end;
end);
(exports).escape = (function (this, html)
if true then return String(global, html):replace(_regexp("&", "g"), ("&amp;")):replace(_regexp("\"", "g"), ("&quot;")):replace(_regexp("<", "g"), ("&lt;")):replace(_regexp(">", "g"), ("&gt;")); end;
end);
(exports).pathRegexp = (function (this, path, keys, sensitive, strict)
if _truthy((toString:call(path) == ("[object RegExp]"))) then
if true then return path; end;
end
if _truthy(Array:isArray(path)) then
path = ((("(") + path:join(("|"))) + (")"));
end
path = path:concat((_truthy(strict) and {("")} or {("/?")})[1]):replace(_regexp("\\/\\(", "g"), ("(?:/")):replace(_regexp("(\\/)?(\\.)?:(\\w+)(?:(\\(.*?\\)))?(\\?)?(\\*)?", "g"), (function (this, __, slash, format, key, capture, optional, star)
if keys:push(_obj({
  ["name"]=key,
  ["optional"]=(not ((not (optional))))})) then end;
slash = slash or ("");
if true then return ((((((((("")
        + ((_truthy(optional) and {("")} or {slash})[1]))
        + ("(?:"))
        + ((_truthy(optional) and {slash} or {("")})[1]))
        + (format or (""))) + (capture or format and ("([^/.]+?)") or ("([^/]+?)"))) + (")"))
        + (optional or ("")))
        + ((_truthy(star) and {("(/*)?")} or {("")})[1])); end;
end)):replace(_regexp("([\\/.])", "g"), ("\\$1")):replace(_regexp("\\*", "g"), ("(.*)"));
if true then return _new(RegExp, ((("^") + path) + ("$")), (_truthy(sensitive) and {("")} or {("i")})[1]); end;
end)
;

return _module.exports;
end