

function (_ENV)
local string, math, print, type, pairs = nil, nil, nil, nil, nil;
local _module = _obj({exports=_obj({})}); local exports, module = _module.exports, _module;

local EventEmitter, spawn, keypress, fs, exists, path, tty, dirname, basename, Option, Command, camelcase, parseBool, pad, outputHelpIfNecessary = EventEmitter, spawn, keypress, fs, exists, path, tty, dirname, basename, Option, Command, camelcase, parseBool, pad, outputHelpIfNecessary;
Option = (function (this, flags, description)
local Option = _debug.getinfo(1, 'f').func;
(this).flags = flags;
(this).required = _bit.bnot(flags:indexOf(("<")));
(this).optional = _bit.bnot(flags:indexOf(("[")));
(this).bool = (not (_bit.bnot(flags:indexOf(("-no-")))));
flags = flags:split(_regexp("[ ,|]+", ""));
if _truthy(((flags).length > (1)) and (not (_regexp("^[[<]", ""):test(flags[(1)])))) then
(this).short = flags:shift();
end
(this).long = flags:shift();
(this).description = description or ("");
end);
Command = (function (this, name)
local Command = _debug.getinfo(1, 'f').func;
(this).commands = _arr({});
(this).options = _arr({});
(this)._args = _arr({});
(this)._name = name;
end);
camelcase = (function (this, flag)
local camelcase = _debug.getinfo(1, 'f').func;
if true then return flag:split(("-")):reduce((function (this, str, word)
if true then return ((str + (word)[(0)]:toUpperCase()) + word:slice((1))); end;
end)); end;
end);
parseBool = (function (this, str)
local parseBool = _debug.getinfo(1, 'f').func;
if true then return _regexp("^y|yes|ok|true$", "i"):test(str); end;
end);
pad = (function (this, str, width)
local pad = _debug.getinfo(1, 'f').func;
local len = len;
len = Math:max((0), (width - (str).length));
if true then return (str + Array(global, (len + (1))):join((" "))); end;
end);
outputHelpIfNecessary = (function (this, cmd, options)
local outputHelpIfNecessary = _debug.getinfo(1, 'f').func;
local i = i;
options = options or _arr({});
i = (0);
while (i < (options).length) do

if _truthy(((options)[i] == ("--help")) or ((options)[i] == ("-h"))) then
if cmd:outputHelp() then end;
if process:exit((0)) then end;
end

if (function () local _r = i; i = _r + 1; return _r end)() then end;
end
end);
EventEmitter = (require(global, ("events"))).EventEmitter;
spawn = (require(global, ("child_process"))).spawn;
keypress = require(global, ("keypress"));
fs = require(global, ("fs"));
exists = (fs).existsSync;
path = require(global, ("path"));
tty = require(global, ("tty"));
dirname = (path).dirname;
basename = (path).basename;
exports = (function () local _r = _new(Command); (module).exports = _r; return _r; end)();
(exports).Command = Command;
(exports).Option = Option;
((Option).prototype).name = (function (this)
if true then return (this).long:replace(("--"), ("")):replace(("no-"), ("")); end;
end);
((Option).prototype).is = (function (this, arg)
if true then return (arg == (this).short) or (arg == (this).long); end;
end);
((Command).prototype).__proto__ = (EventEmitter).prototype;
((Command).prototype).command = (function (this, name, desc)
local args, cmd = args, cmd;
args = name:split(_regexp(" +", ""));
cmd = _new(Command, args:shift());
if _truthy(desc) then
if cmd:description(desc) then end;
end
if _truthy(desc) then
(this).executables = (true);
end
if (this).commands:push(cmd) then end;
if cmd:parseExpectedArgs(args) then end;
(cmd).parent = this;
if _truthy(desc) then
if true then return this; end;
end
if true then return cmd; end;
end);
((Command).prototype).addImplicitHelpCommand = (function (this)
if this:command(("help [cmd]"), ("display help for [cmd]")) then end;
end);
((Command).prototype).parseExpectedArgs = (function (this, args)
local self = self;
if (not ((args).length)) then
if true then return; end;
end
self = this;
if args:forEach((function (this, arg)
repeat
local _0 = ("<"); local _1 = ("[");
local _r = (arg)[(0)];
if _r == _0 then
if (self)._args:push(_obj({
  ["required"]=true,
  ["name"]=arg:slice((1), (-(1)))})) then end;
_c = _break; break;
end
if _r == _1 then
if (self)._args:push(_obj({
  ["required"]=false,
  ["name"]=arg:slice((1), (-(1)))})) then end;
_c = _break; break;
end
until true
end)) then end;
if true then return this; end;
end);
((Command).prototype).action = (function (this, fn)
local self = self;
self = this;
if (this).parent:on(this._name, (function (this, args, unknown)
local parsed = parsed;
unknown = unknown or _arr({});
parsed = self:parseOptions(unknown);
if outputHelpIfNecessary(global, self, parsed.unknown) then end;
if (((parsed).unknown).length > (0)) then
if self:unknownOption((parsed).unknown[(0)]) then end;
end
if _truthy(((parsed).args).length) then
args = (parsed).args:concat(args);
end
if (self)._args:forEach((function (this, arg, i)
if _truthy((arg).required and ((null) == (args)[i])) then
if self:missingArgument(arg.name) then end;
end
end)) then end;
if _truthy(((self)._args).length) then
(args)[((self)._args).length] = self;
else
if args:push(self) then end;
end
if fn:apply(this, args) then end;
end)) then end;
if true then return this; end;
end);
((Command).prototype).option = (function (this, flags, description, fn, defaultValue)
local self, option, oname, name = self, option, oname, name;
self = this;
option = _new(Option, flags, description);
oname = option:name();
name = camelcase(global, oname);
if (("function") ~= _typeof(fn)) then
_seq({(function () local _r = fn; defaultValue = _r; return _r; end)(), (function () local _r = (null); fn = _r; return _r; end)()});
end
if _truthy(((false) == (option).bool) or (option).optional or (option).required) then
if _truthy(((false) == (option).bool)) then
defaultValue = (true);
end
if (undefined ~= defaultValue) then
(self)[name] = defaultValue;
end
end
if (this).options:push(option) then end;
if this:on(oname, (function (this, val)
if _truthy(((null) ~= val) and fn) then
val = fn(global, val);
end
if _truthy((("boolean") == _typeof((self)[name])) or (("undefined") == _typeof((self)[name]))) then
if _truthy(((null) == val)) then
(self)[name] = (_truthy((option).bool) and {defaultValue or (true)} or {(false)})[1];
else
(self)[name] = val;
end
else
if ((null) ~= val) then
(self)[name] = val;
end
end
end)) then end;
if true then return this; end;
end);
((Command).prototype).parse = (function (this, argv)
local parsed, args = parsed, args;
if _truthy((this).executables) then
if this:addImplicitHelpCommand() then end;
end
(this).rawArgs = argv;
(this)._name = (this)._name or basename(global, argv[(1)]);
parsed = this:parseOptions(this:normalize(argv:slice((2))));
args = (function () local _r = (parsed).args; (this).args = _r; return _r; end)();
if _truthy((this).executables) then
if true then return this:executeSubCommand(argv, args, parsed.unknown); end;
end
if true then return this:parseArgs(this.args, parsed.unknown); end;
end);
((Command).prototype).executeSubCommand = (function (this, argv, args, unknown)
local dir, bin, local, proc = dir, bin, local, proc;
args = args:concat(unknown);
if (not ((args).length)) then
if this:help() then end;
end
if _truthy((("help") == (args)[(0)]) and ((1) == (args).length)) then
if this:help() then end;
end
if _truthy((("help") == (args)[(0)])) then
(args)[(0)] = (args)[(1)];
(args)[(1)] = ("--help");
end
dir = dirname(global, argv[(1)]);
bin = ((basename(global, argv[(1)]) + ("-")) + (args)[(0)]);
local = path:join(dir, bin);
if _truthy(exists(global, local)) then
bin = local;
end
args = args:slice((1));
proc = spawn(global, bin, args, _obj({
  ["stdio"]=("inherit"),
  ["customFds"]=_arr({[0]=(0), (1), (2)})}));
if proc:on(("exit"), (function (this, code)
if _truthy((code == (127))) then
if (function () local base, prop = console, "error"; return base[prop](base, ("\n  %s(1) does not exist\n"), bin); end)() then end;
end
end)) then end;
end);
((Command).prototype).normalize = (function (this, args)
local ret, arg, index, i, len = ret, arg, index, i, len;
ret = _arr({});
arg = nil;
index = nil;
i = (0);
len = (args).length;
while (i < len) do

arg = (args)[i];
if _truthy(((arg).length > (1)) and (("-") == (arg)[(0)]) and (("-") ~= (arg)[(1)])) then
if arg:slice((1)):split(("")):forEach((function (this, c)
if ret:push((("-") + c)) then end;
end)) then end;
else
if _truthy(_regexp("^--", ""):test(arg) and _bit.bnot((function () local _r = arg:indexOf(("=")); index = _r; return _r; end)())) then
if ret:push(arg:slice((0), index), arg:slice((index + (1)))) then end;
else
if ret:push(arg) then end;
end
end

if (function () i = i + 1; return i; end)() then end;
end
if true then return ret; end;
end);
((Command).prototype).parseArgs = (function (this, args, unknown)
local cmds, len, name = cmds, len, name;
cmds = (this).commands;
len = (cmds).length;
name = nil;
if _truthy((args).length) then
name = (args)[(0)];
if _truthy((this:listeners(name)).length) then
if this:emit(args:shift(), args, unknown) then end;
else
if this:emit(("*"), args) then end;
end
else
if outputHelpIfNecessary(global, this, unknown) then end;
if ((unknown).length > (0)) then
if this:unknownOption(unknown[(0)]) then end;
end
end
if true then return this; end;
end);
((Command).prototype).optionFor = (function (this, arg)
local i, len = i, len;
i = (0);
len = ((this).options).length;
while (i < len) do

if _truthy(((this).options)[i]:is(arg)) then
if true then return ((this).options)[i]; end;
end

if (function () i = i + 1; return i; end)() then end;
end
end);
((Command).prototype).parseOptions = (function (this, argv)
local args, len, literal, option, arg, unknownOptions, i = args, len, literal, option, arg, unknownOptions, i;
args = _arr({});
len = (argv).length;
literal = nil;
option = nil;
arg = nil;
unknownOptions = _arr({});
i = (0);
while (i < len) do
local _c = nil; repeat
arg = (argv)[i];
if _truthy((("--") == arg)) then
literal = (true);
_c = _cont; break;
end
if _truthy(literal) then
if args:push(arg) then end;
_c = _cont; break;
end
option = this:optionFor(arg);
if _truthy(option) then
if _truthy((option).required) then
arg = (argv)[(function () i = i + 1; return i; end)()];
if _truthy(((null) == arg)) then
if true then return this:optionMissingArgument(option); end;
end
if _truthy((("-") == (arg)[(0)]) and (("-") ~= arg)) then
if true then return this:optionMissingArgument(option, arg); end;
end
if this:emit(option:name(), arg) then end;
else
if _truthy((option).optional) then
arg = (argv)[(i+(1))];
if _truthy(((null) == arg) or (("-") == (arg)[(0)]) and (("-") ~= arg)) then
arg = (null);
else
(function () i = i + 1; return i; end)();
end
if this:emit(option:name(), arg) then end;
else
if this:emit(option:name()) then end;
end
end
_c = _cont; break;
end
if _truthy(((arg).length > (1)) and (("-") == (arg)[(0)])) then
if unknownOptions:push(arg) then end;
if _truthy((argv)[(i+(1))] and (("-") ~= ((argv)[(i+(1))])[(0)])) then
if unknownOptions:push(argv[(function () i = i + 1; return i; end)()]) then end;
end
_c = _cont; break;
end
if args:push(arg) then end;
until true;
if _c == _break then break end
if (function () i = i + 1; return i; end)() then end;
end
if true then return _obj({
  ["args"]=args,
  ["unknown"]=unknownOptions}); end;
end);
((Command).prototype).missingArgument = (function (this, name)
if (function () local base, prop = console, "error"; return base[prop](base); end)() then end;
if (function () local base, prop = console, "error"; return base[prop](base, ("  error: missing required argument `%s'"), name); end)() then end;
if (function () local base, prop = console, "error"; return base[prop](base); end)() then end;
if process:exit((1)) then end;
end);
((Command).prototype).optionMissingArgument = (function (this, option, flag)
if (function () local base, prop = console, "error"; return base[prop](base); end)() then end;
if _truthy(flag) then
if (function () local base, prop = console, "error"; return base[prop](base, ("  error: option `%s' argument missing, got `%s'"), option.flags, flag); end)() then end;
else
if (function () local base, prop = console, "error"; return base[prop](base, ("  error: option `%s' argument missing"), option.flags); end)() then end;
end
if (function () local base, prop = console, "error"; return base[prop](base); end)() then end;
if process:exit((1)) then end;
end);
((Command).prototype).unknownOption = (function (this, flag)
if (function () local base, prop = console, "error"; return base[prop](base); end)() then end;
if (function () local base, prop = console, "error"; return base[prop](base, ("  error: unknown option `%s'"), flag); end)() then end;
if (function () local base, prop = console, "error"; return base[prop](base); end)() then end;
if process:exit((1)) then end;
end);
((Command).prototype).version = (function (this, ...)
local arguments = _arguments(...);
local str, flags = ...;
if _truthy(((0) == (arguments).length)) then
if true then return (this)._version; end;
end
(this)._version = str;
flags = flags or ("-V, --version");
if this:option(flags, ("output the version number")) then end;
if this:on(("version"), (function (this)
if console:log(str) then end;
if process:exit((0)) then end;
end)) then end;
if true then return this; end;
end);
((Command).prototype).description = (function (this, ...)
local arguments = _arguments(...);
local str = ...;
if _truthy(((0) == (arguments).length)) then
if true then return (this)._description; end;
end
(this)._description = str;
if true then return this; end;
end);
((Command).prototype).usage = (function (this, ...)
local arguments = _arguments(...);
local str = ...;
local args, usage = args, usage;
args = (this)._args:map((function (this, arg)
if true then return (_truthy((arg).required) and {((("<") + (arg).name) + (">"))} or {((("[") + (arg).name) + ("]"))})[1]; end;
end));
usage = (((("[options")
    + ((_truthy(((this).commands).length) and {("] [command")} or {("")})[1]))
    + ("]"))
    + ((_truthy(((this)._args).length) and {((" ") + args)} or {("")})[1]));
if _truthy(((0) == (arguments).length)) then
if true then return (this)._usage or usage; end;
end
(this)._usage = str;
if true then return this; end;
end);
((Command).prototype).largestOptionLength = (function (this)
if true then return (this).options:reduce((function (this, max, option)
if true then return Math:max(max, (option).flags.length); end;
end), (0)); end;
end);
((Command).prototype).optionHelp = (function (this)
local width = width;
width = this:largestOptionLength();
if true then return _arr({[0]=((pad(global, ("-h, --help"), width) + ("  ")) + ("output usage information"))}):concat((this).options:map((function (this, option)
if true then return ((pad(global, option.flags, width)
        + ("  ")) + (option).description); end;
end))):join(("\n")); end;
end);
((Command).prototype).commandHelp = (function (this)
if (not (((this).commands).length)) then
if true then return (""); end;
end
if true then return _arr({[0]=(""), ("  Commands:"), (""), (this).commands:map((function (this, cmd)
local args = args;
args = (cmd)._args:map((function (this, arg)
if true then return (_truthy((arg).required) and {((("<") + (arg).name) + (">"))} or {((("[") + (arg).name) + ("]"))})[1]; end;
end)):join((" "));
if true then return (pad(global, ((((cmd)._name
        + ((_truthy(((cmd).options).length) and {(" [options]")} or {("")})[1])) + (" ")) + args), (22))
        + ((_truthy(cmd:description()) and {((" ") + cmd:description())} or {("")})[1])); end;
end)):join(("\n")):replace(_regexp("^", "gm"), ("    ")), ("")}):join(("\n")); end;
end);
((Command).prototype).helpInformation = (function (this)
if true then return _arr({[0]=(""), (((("  Usage: ") + (this)._name) + (" ")) + this:usage()), (("") + this:commandHelp()), ("  Options:"), (""), (("") + this:optionHelp():replace(_regexp("^", "gm"), ("    "))), (""), ("")}):join(("\n")); end;
end);
((Command).prototype).promptForNumber = (function (this, str, fn)
local self, parseNumber = self, parseNumber;
self = this;
if this:promptSingleLine(str, (function (this, val)
local parseNumber = _debug.getinfo(1, 'f').func;
val = Number(global, val);
if _truthy(isNaN(global, val)) then
if true then return self:promptSingleLine((str + ("(must be a number) ")), parseNumber); end;
end
if fn(global, val) then end;
end)) then end;
end);
((Command).prototype).promptForDate = (function (this, str, fn)
local self, parseDate = self, parseDate;
self = this;
if this:promptSingleLine(str, (function (this, val)
local parseDate = _debug.getinfo(1, 'f').func;
val = _new(Date, val);
if _truthy(isNaN(global, val:getTime())) then
if true then return self:promptSingleLine((str + ("(must be a date) ")), parseDate); end;
end
if fn(global, val) then end;
end)) then end;
end);
((Command).prototype).promptForRegexp = (function (this, str, pattern, fn)
local self, parseRegexp = self, parseRegexp;
self = this;
if this:promptSingleLine(str, (function (this, val)
local parseRegexp = _debug.getinfo(1, 'f').func;
if (not (pattern:test(val))) then
if true then return self:promptSingleLine((str + ("(regular expression mismatch) ")), parseRegexp); end;
end
if fn(global, val) then end;
end)) then end;
end);
((Command).prototype).promptSingleLine = (function (this, ...)
local arguments = _arguments(...);
local str, fn = ...;
if _truthy((((arguments)[(1)]).global ~= undefined) and (((arguments)[(1)]).multiline ~= undefined)) then
if true then return this:promptForRegexp(str, arguments[(1)], arguments[(2)]); end;
else
if _truthy((("function") == _typeof((arguments)[(2)]))) then
if true then return (function () local base, prop = this, (("promptFor") + ((fn).name or fn)); return base[prop](base, str, arguments[(2)]); end)(); end;
end
end
if (process).stdout:write(str) then end;
if (process).stdin:setEncoding(("utf8")) then end;
if (process).stdin:once(("data"), (function (this, val)
if fn(global, val:trim()) then end;
end)):resume() then end;
end);
((Command).prototype).promptMultiLine = (function (this, str, fn)
local buf = buf;
buf = _arr({});
if console:log(str) then end;
if (process).stdin:setEncoding(("utf8")) then end;
if (process).stdin:on(("data"), (function (this, val)
if _truthy((("\n") == val) or (("\r\n") == val)) then
if (process).stdin:removeAllListeners(("data")) then end;
if fn(global, buf:join(("\n"))) then end;
else
if buf:push(val:trimRight()) then end;
end
end)):resume() then end;
end);
((Command).prototype).prompt = (function (this, ...)
local arguments = _arguments(...);
local str, fn = ...;
local self, keys, obj, next = self, keys, obj, next;
self = this;
if _truthy((("string") == _typeof(str))) then
if _truthy(_regexp(" $", ""):test(str)) then
if true then return (this).promptSingleLine:apply(this, arguments); end;
end
if this:promptMultiLine(str, fn) then end;
else
next = (function (this)
local next = _debug.getinfo(1, 'f').func;
local key, label = key, label;
key = keys:shift();
label = (str)[key];
if (not (key)) then
if true then return fn(global, obj); end;
end
if self:prompt(label, (function (this, val)
(obj)[key] = val;
if next(global) then end;
end)) then end;
end);
keys = Object:keys(str);
obj = _obj({
  });
if next(global) then end;
end
end);
((Command).prototype).password = (function (this, str, mask, fn)
local self, buf, setRawMode = self, buf, setRawMode;
setRawMode = (function (this, mode)
local setRawMode = _debug.getinfo(1, 'f').func;
if _truthy(((process).stdin).setRawMode) then
if (process).stdin:setRawMode(mode) then end;
else
if tty:setRawMode(mode) then end;
end
end);
self = this;
buf = ("");
if _truthy((("function") == _typeof(mask))) then
fn = mask;
mask = ("");
end
if keypress(global, process.stdin) then end;
if setRawMode(global, (true)) then end;
if (process).stdout:write(str) then end;
if (process).stdin:on(("keypress"), (function (this, c, key)
if _truthy(key and (("enter") == (key).name)) then
if console:log() then end;
if (process).stdin:pause() then end;
if (process).stdin:removeAllListeners(("keypress")) then end;
if setRawMode(global, (false)) then end;
if (not ((buf:trim()).length)) then
if true then return self:password(str, mask, fn); end;
end
if fn(global, buf) then end;
if true then return; end;
end
if _truthy(key and (key).ctrl and (("c") == (key).name)) then
if console:log(("%s"), buf) then end;
if process:exit() then end;
end
if (process).stdout:write(mask) then end;
buf = buf + c;
end)):resume() then end;
end);
((Command).prototype).confirm = (function (this, str, fn, verbose)
local self = self;
self = this;
if this:prompt(str, (function (this, ok)
if (not (ok:trim())) then
if (not (verbose)) then
str = str + ("(yes or no) ");
end
if true then return self:confirm(str, fn, (true)); end;
end
if fn(global, parseBool(global, ok)) then end;
end)) then end;
end);
((Command).prototype).choose = (function (this, list, index, fn)
local self, hasDefault, again = self, hasDefault, again;
again = (function (this)
local again = _debug.getinfo(1, 'f').func;
if self:prompt(("  : "), (function (this, val)
val = (parseInt(global, val, (10)) - (1));
if _truthy(hasDefault and isNaN(global, val)) then
val = index;
end
if _truthy(((null) == (list)[val])) then
if again(global) then end;
else
if fn(global, val, list[val]) then end;
end
end)) then end;
end);
self = this;
hasDefault = (("number") == _typeof(index));
if (not (hasDefault)) then
fn = index;
index = (null);
end
if list:forEach((function (this, item, i)
if _truthy(hasDefault and (i == index)) then
if console:log(("* %d) %s"), (i + (1)), item) then end;
else
if console:log(("  %d) %s"), (i + (1)), item) then end;
end
end)) then end;
if again(global) then end;
end);
((Command).prototype).outputHelp = (function (this)
if (process).stdout:write(this:helpInformation()) then end;
if this:emit(("--help")) then end;
end);
((Command).prototype).help = (function (this)
if this:outputHelp() then end;
if process:exit() then end;
end);

return _module.exports;
end