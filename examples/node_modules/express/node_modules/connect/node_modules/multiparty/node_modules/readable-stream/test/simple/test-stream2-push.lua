-- Copyright Joyent, Inc. and other Node contributors.
--
-- Permission is hereby granted, free of charge, to any person obtaining a
-- copy of this software and associated documentation files (the
-- "Software"), to deal in the Software without restriction, including
-- without limitation the rights to use, copy, modify, merge, publish,
-- distribute, sublicense, and/or sell copies of the Software, and to permit
-- persons to whom the Software is furnished to do so, subject to the
-- following conditions:
--
-- The above copyright notice and this permission notice shall be included
-- in all copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-- OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-- MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
-- NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
-- DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
-- OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
-- USE OR OTHER DEALINGS IN THE SOFTWARE.

function (_ENV)
local string, math, print, type, pairs = nil, nil, nil, nil, nil;
local _module = _obj({exports=_obj({})}); local exports, module = _module.exports, _module;

local common, stream, Readable, Writable, assert, util, EE, source, ended, reading, readStart, readStop, writer, written, expectWritten, chunk, set, data, finish, __K__end = common, stream, Readable, Writable, assert, util, EE, source, ended, reading, readStart, readStop, writer, written, expectWritten, chunk, set, data, finish, __K__end;
readStart = (function (this)
local readStart = _debug.getinfo(1, 'f').func;
if (function () local base, prop = console, "error"; return base[prop](base, ("readStart")); end)() then end;
reading = (true);
end);
readStop = (function (this)
local readStop = _debug.getinfo(1, 'f').func;
if (function () local base, prop = console, "error"; return base[prop](base, ("readStop")); end)() then end;
reading = (false);
if process:nextTick((function (this)
local r = r;
r = stream:read();
if (r ~= (null)) then
if writer:write(r) then end;
end
end)) then end;
end);
data = (function (this)
local data = _debug.getinfo(1, 'f').func;
if assert(global, reading) then end;
if source:emit(("data"), chunk) then end;
if assert(global, reading) then end;
if source:emit(("data"), chunk) then end;
if assert(global, reading) then end;
if source:emit(("data"), chunk) then end;
if assert(global, reading) then end;
if source:emit(("data"), chunk) then end;
if assert(global, (not (reading))) then end;
if ((function () local _r = set; set = _r + 1; return _r end)() < (5)) then
if setTimeout(global, data, (10)) then end;
else
if _K_end(global) then end;
end
end);
finish = (function (this)
local finish = _debug.getinfo(1, 'f').func;
if (function () local base, prop = console, "error"; return base[prop](base, ("finish")); end)() then end;
if assert:deepEqual(written, expectWritten) then end;
if console:log(("ok")) then end;
end);
_K_end = (function (this)
local _K_end = _debug.getinfo(1, 'f').func;
if source:emit(("end")) then end;
if assert(global, (not (reading))) then end;
if (function () local base, prop = writer, "end"; return base[prop](base, stream:read()); end)() then end;
if setTimeout(global, (function (this)
if assert(global, ended) then end;
end)) then end;
end);
common = require(global, ("../common.js"));
stream = require(global, ("../../readable"));
Readable = (stream).Readable;
Writable = (stream).Writable;
assert = require(global, ("assert"));
util = require(global, ("util"));
EE = (require(global, ("events"))).EventEmitter;
stream = _new(Readable, _obj({
  ["highWaterMark"]=16,
  ["encoding"]=("utf8")}));
source = _new(EE);
(stream)._read = (function (this)
if (function () local base, prop = console, "error"; return base[prop](base, ("stream._read")); end)() then end;
if readStart(global) then end;
end);
ended = (false);
if stream:on(("end"), (function (this)
ended = (true);
end)) then end;
if source:on(("data"), (function (this, chunk)
local ret = ret;
ret = stream:push(chunk);
if (function () local base, prop = console, "error"; return base[prop](base, ("data"), (stream)._readableState.length); end)() then end;
if (not (ret)) then
if readStop(global) then end;
end
end)) then end;
if source:on(("end"), (function (this)
if stream:push((null)) then end;
end)) then end;
reading = (false);
writer = _new(Writable, _obj({
  ["decodeStrings"]=false}));
written = _arr({});
expectWritten = _arr({[0]=("asdfgasdfgasdfgasdfg"), ("asdfgasdfgasdfgasdfg"), ("asdfgasdfgasdfgasdfg"), ("asdfgasdfgasdfgasdfg"), ("asdfgasdfgasdfgasdfg"), ("asdfgasdfgasdfgasdfg")});
(writer)._write = (function (this, chunk, encoding, cb)
if (function () local base, prop = console, "error"; return base[prop](base, ("WRITE %s"), chunk); end)() then end;
if written:push(chunk) then end;
if process:nextTick(cb) then end;
end);
if writer:on(("finish"), finish) then end;
chunk = ("asdfg");
set = (0);
if readStart(global) then end;
if data(global) then end;

return _module.exports;
end