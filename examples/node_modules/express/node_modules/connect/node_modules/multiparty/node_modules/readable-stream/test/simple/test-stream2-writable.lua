-- Copyright Joyent, Inc. and other Node contributors.
--
-- Permission is hereby granted, free of charge, to any person obtaining a
-- copy of this software and associated documentation files (the
-- "Software"), to deal in the Software without restriction, including
-- without limitation the rights to use, copy, modify, merge, publish,
-- distribute, sublicense, and/or sell copies of the Software, and to permit
-- persons to whom the Software is furnished to do so, subject to the
-- following conditions:
--
-- The above copyright notice and this permission notice shall be included
-- in all copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-- OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-- MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
-- NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
-- DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
-- OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
-- USE OR OTHER DEALINGS IN THE SOFTWARE.

function (_ENV)
local string, math, print, type, pairs = nil, nil, nil, nil, nil;
local _module = _obj({exports=_obj({})}); local exports, module = _module.exports, _module;

local common, W, D, assert, util, TestWriter, chunks, i, tests, count, test, run = common, W, D, assert, util, TestWriter, chunks, i, tests, count, test, run;
TestWriter = (function (this, ...)
local TestWriter = _debug.getinfo(1, 'f').func;
local arguments = _arguments(...);
if W:apply(this, arguments) then end;
(this).buffer = _arr({});
(this).written = (0);
end);
test = (function (this, name, fn)
local test = _debug.getinfo(1, 'f').func;
(function () local _r = count; count = _r + 1; return _r end)();
if tests:push(_arr({[0]=name, fn})) then end;
end);
run = (function (this)
local run = _debug.getinfo(1, 'f').func;
local next, name, fn = next, name, fn;
next = tests:shift();
if (not (next)) then
if true then return (function () local base, prop = console, "error"; return base[prop](base, ("ok")); end)(); end;
end
name = (next)[(0)];
fn = (next)[(1)];
if console:log(("# %s"), name) then end;
if fn(global, _obj({
  ["same"]=(assert).deepEqual,
  ["equal"]=(assert).equal,
  ["end"]=(function (this)
(function () local _r = count; count = _r - 1; return _r end)();
if run(global) then end;
end)})) then end;
end);
common = require(global, ("../common.js"));
W = require(global, ("../../lib/_stream_writable"));
D = require(global, ("../../lib/_stream_duplex"));
assert = require(global, ("assert"));
util = require(global, ("util"));
if util:inherits(TestWriter, W) then end;
((TestWriter).prototype)._write = (function (this, chunk, encoding, cb)
if setTimeout(global, (function (this)
if (this).buffer:push(chunk:toString()) then end;
(this).written = (this).written + (chunk).length;
if cb(global) then end;
end):bind(this), Math:floor((Math:random() * (10)))) then end;
end);
chunks = _new(Array, (50));
i = (0);
while (i < (chunks).length) do

(chunks)[i] = _new(Array, (i + (1))):join(("x"));

if (function () local _r = i; i = _r + 1; return _r end)() then end;
end
tests = _arr({});
count = (0);
if process:on(("exit"), (function (this)
if assert:equal(count, (0)) then end;
end)) then end;
if process:nextTick(run) then end;
if test(global, ("write fast"), (function (this, t)
local tw = tw;
tw = _new(TestWriter, _obj({
  ["highWaterMark"]=100}));
if tw:on(("finish"), (function (this)
if t:same(tw.buffer, chunks, ("got chunks in the right order")) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end)) then end;
if chunks:forEach((function (this, chunk)
if tw:write(chunk) then end;
end)) then end;
if (function () local base, prop = tw, "end"; return base[prop](base); end)() then end;
end)) then end;
if test(global, ("write slow"), (function (this, t)
local tw, i, W = tw, i, W;
tw = _new(TestWriter, _obj({
  ["highWaterMark"]=100}));
if tw:on(("finish"), (function (this)
if t:same(tw.buffer, chunks, ("got chunks in the right order")) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end)) then end;
i = (0);
if (function (this)
local W = _debug.getinfo(1, 'f').func;
if tw:write(chunks[(function () local _r = i; i = _r + 1; return _r end)()]) then end;
if (i < (chunks).length) then
if setTimeout(global, W, (10)) then end;
else
if (function () local base, prop = tw, "end"; return base[prop](base); end)() then end;
end
end)(global) then end;
end)) then end;
if test(global, ("write backpressure"), (function (this, t)
local tw, drains, i, W = tw, drains, i, W;
tw = _new(TestWriter, _obj({
  ["highWaterMark"]=50}));
drains = (0);
if tw:on(("finish"), (function (this)
if t:same(tw.buffer, chunks, ("got chunks in the right order")) then end;
if t:equal(drains, (17)) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end)) then end;
if tw:on(("drain"), (function (this)
(function () local _r = drains; drains = _r + 1; return _r end)();
end)) then end;
i = (0);
if (function (this)
local W = _debug.getinfo(1, 'f').func;
local ret = ret;
repeat

ret = tw:write(chunks[(function () local _r = i; i = _r + 1; return _r end)()]);

until not _truthy((ret ~= (false)) and (i < (chunks).length));
if (i < (chunks).length) then
if assert(global, (((tw)._writableState).length >= (50))) then end;
if tw:once(("drain"), W) then end;
else
if (function () local base, prop = tw, "end"; return base[prop](base); end)() then end;
end
end)(global) then end;
end)) then end;
if test(global, ("write bufferize"), (function (this, t)
local tw, encodings = tw, encodings;
tw = _new(TestWriter, _obj({
  ["highWaterMark"]=100}));
encodings = _arr({[0]=("hex"), ("utf8"), ("utf-8"), ("ascii"), ("binary"), ("base64"), ("ucs2"), ("ucs-2"), ("utf16le"), ("utf-16le"), undefined});
if tw:on(("finish"), (function (this)
if t:same(tw.buffer, chunks, ("got the expected chunks")) then end;
end)) then end;
if chunks:forEach((function (this, chunk, i)
local enc = enc;
enc = (encodings)[(i % (encodings).length)];
chunk = _new(Buffer, chunk);
if tw:write(chunk:toString(enc), enc) then end;
end)) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end)) then end;
if test(global, ("write no bufferize"), (function (this, t)
local tw, encodings = tw, encodings;
tw = _new(TestWriter, _obj({
  ["highWaterMark"]=100,
  ["decodeStrings"]=false}));
(tw)._write = (function (this, chunk, encoding, cb)
if assert(global, (_typeof(chunk) == ("string"))) then end;
chunk = _new(Buffer, chunk, encoding);
if true then return ((TestWriter).prototype)._write:call(this, chunk, encoding, cb); end;
end);
encodings = _arr({[0]=("hex"), ("utf8"), ("utf-8"), ("ascii"), ("binary"), ("base64"), ("ucs2"), ("ucs-2"), ("utf16le"), ("utf-16le"), undefined});
if tw:on(("finish"), (function (this)
if t:same(tw.buffer, chunks, ("got the expected chunks")) then end;
end)) then end;
if chunks:forEach((function (this, chunk, i)
local enc = enc;
enc = (encodings)[(i % (encodings).length)];
chunk = _new(Buffer, chunk);
if tw:write(chunk:toString(enc), enc) then end;
end)) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end)) then end;
if test(global, ("write callbacks"), (function (this, t)
local callbacks, tw = callbacks, tw;
callbacks = chunks:map((function (this, chunk, i)
if true then return _arr({[0]=i, (function (this, er)
((callbacks)._called)[i] = chunk;
end)}); end;
end)):reduce((function (this, set, x)
(set)[(("callback-") + (x)[(0)])] = (x)[(1)];
if true then return set; end;
end), _obj({
  }));
(callbacks)._called = _arr({});
tw = _new(TestWriter, _obj({
  ["highWaterMark"]=100}));
if tw:on(("finish"), (function (this)
if process:nextTick((function (this)
if t:same(tw.buffer, chunks, ("got chunks in the right order")) then end;
if t:same(callbacks._called, chunks, ("called all callbacks")) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end)) then end;
end)) then end;
if chunks:forEach((function (this, chunk, i)
if tw:write(chunk, callbacks[(("callback-") + i)]) then end;
end)) then end;
if (function () local base, prop = tw, "end"; return base[prop](base); end)() then end;
end)) then end;
if test(global, ("end callback"), (function (this, t)
local tw = tw;
tw = _new(TestWriter);
if (function () local base, prop = tw, "end"; return base[prop](base, (function (this)
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end)); end)() then end;
end)) then end;
if test(global, ("end callback with chunk"), (function (this, t)
local tw = tw;
tw = _new(TestWriter);
if (function () local base, prop = tw, "end"; return base[prop](base, _new(Buffer, ("hello world")), (function (this)
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end)); end)() then end;
end)) then end;
if test(global, ("end callback with chunk and encoding"), (function (this, t)
local tw = tw;
tw = _new(TestWriter);
if (function () local base, prop = tw, "end"; return base[prop](base, ("hello world"), ("ascii"), (function (this)
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end)); end)() then end;
end)) then end;
if test(global, ("end callback after .write() call"), (function (this, t)
local tw = tw;
tw = _new(TestWriter);
if tw:write(_new(Buffer, ("hello world"))) then end;
if (function () local base, prop = tw, "end"; return base[prop](base, (function (this)
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end)); end)() then end;
end)) then end;
if test(global, ("encoding should be ignored for buffers"), (function (this, t)
local tw, hex, buf = tw, hex, buf;
tw = _new(W);
hex = ("018b5e9a8f6236ffe30e31baf80d2cf6eb");
(tw)._write = (function (this, chunk, encoding, cb)
if t:equal(chunk:toString(("hex")), hex) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end);
buf = _new(Buffer, hex, ("hex"));
if tw:write(buf, ("binary")) then end;
end)) then end;
if test(global, ("writables are not pipable"), (function (this, t)
local w, gotError = w, gotError;
w = _new(W);
(w)._write = (function (this)

end);
gotError = (false);
if w:on(("error"), (function (this, er)
gotError = (true);
end)) then end;
if w:pipe(process.stdout) then end;
if assert(global, gotError) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end)) then end;
if test(global, ("duplexes are pipable"), (function (this, t)
local d, gotError = d, gotError;
d = _new(D);
(d)._read = (function (this)

end);
(d)._write = (function (this)

end);
gotError = (false);
if d:on(("error"), (function (this, er)
gotError = (true);
end)) then end;
if d:pipe(process.stdout) then end;
if assert(global, (not (gotError))) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end)) then end;
if test(global, ("end(chunk) two times is an error"), (function (this, t)
local w, gotError = w, gotError;
w = _new(W);
(w)._write = (function (this)

end);
gotError = (false);
if w:on(("error"), (function (this, er)
gotError = (true);
if t:equal(er.message, ("write after end")) then end;
end)) then end;
if (function () local base, prop = w, "end"; return base[prop](base, ("this is the end")); end)() then end;
if (function () local base, prop = w, "end"; return base[prop](base, ("and so is this")); end)() then end;
if process:nextTick((function (this)
if assert(global, gotError) then end;
if (function () local base, prop = t, "end"; return base[prop](base); end)() then end;
end)) then end;
end)) then end;

return _module.exports;
end