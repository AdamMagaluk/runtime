function (_ENV)
local string, math, print, type, pairs = nil, nil, nil, nil, nil;
local _module = {exports={}}; local exports, module = _module.exports, _module;

local EventEmitter, TCP, client = EventEmitter, TCP, client;
TCP = _func(function (this, socket)
local TCP = _debug.getinfo(1, 'f').func;
(this).socket = socket;
end);
EventEmitter = _func(function (this)
local EventEmitter = EventEmitter;
EventEmitter = _func(function (this)
local EventEmitter = _debug.getinfo(1, 'f').func;

end);
((EventEmitter).prototype).listeners = _func(function (this, type)
if true then return (_truthy((this).hasOwnProperty:call((this)._events or (function () local _r = _obj({
  }); (this)._events = _r; return _r; end)(), type)) and {((this)._events)[type]} or {(function () local _r = _arr({}); ((this)._events)[type] = _r; return _r; end)()})[1]; end;
end);
((EventEmitter).prototype).on = (function () local _r = _func(function (this, type, f)
if _truthy(((this)._maxListeners ~= (0)) and (this:listeners(type):push(f) > ((this)._maxListeners or (10)))) then
if console and console:warn(((("Possible EventEmitter memory leak detected. ") + (((this)._events)[type]).length) + (" listeners added. Use emitter.setMaxListeners() to increase limit."))) then end;
end
if this:emit(("newListener"), type, f) then end;
if true then return this; end;
end); ((EventEmitter).prototype).addListener = _r; return _r; end)();
((EventEmitter).prototype).once = _func(function (this, type, f)
local g = g;
if this:on(type, _func(function (this, ...)
local g = _debug.getinfo(1, 'f').func;
local arguments = _arguments(...);
if f:call(this, arguments[(0)], arguments[(1)], arguments[(2)]) then end;
if this:removeListener(type, g)
     then end;
end)) then end;
end);
((EventEmitter).prototype).removeListener = _func(function (this, type, f)
local i = i;
i = nil;
if ((function () local _r = this:listeners(type):indexOf(f); i = _r; return _r; end)() ~= (-(1))) and this:listeners(type):splice(i, (1)) then end;
if true then return this; end;
end);
((EventEmitter).prototype).removeAllListeners = _func(function (this, type)
local k = k;
for k in _pairs((this)._events) do
if (not (type)) or (type == k) and ((this)._events)[k]:splice((0), ((this)._events)[k].length) then end;
end
if true then return this; end;
end);
((EventEmitter).prototype).emit = _func(function (this, ...)
local arguments = _arguments(...);
local type = ...;
local args, i, fns = args, i, fns;
args = ((Array).prototype).slice:call(arguments, (1));
i = (0);
fns = this:listeners(type):slice();
while (i < (fns).length) do

if (fns)[i]:call(this, args[(0)], args[(1)], args[(2)]) then end;

(function () local _r = i; i = _r + 1; return _r end)()
end
if true then return (fns).length; end;
end);
((EventEmitter).prototype).setMaxListeners = _func(function (this, maxListeners)
(this)._maxListeners = maxListeners;
end);
if true then return EventEmitter; end;
end)(global);
(TCP).prototype = _new(EventEmitter);
((TCP).prototype).connect = _func(function (this, port, ip, cb)
local ips, client = ips, client;
ips = ip:split(("."));
client = this;
if setImmediate(global, _func(function (this)
if tm__tcp__connect(global, client.socket, Number(global, ips[(0)]), Number(global, ips[(1)]), Number(global, ips[(2)]), Number(global, ips[(3)]), Number(global, port)) then end;
if setInterval(global, _func(function (this)
local buf = buf;
while (tm__tcp__readable(global, client.socket) > (0)) do

buf = tm__tcp__read(global, client.socket);
if client:emit(("data"), buf) then end;

end
end), (100)) then end;
if cb(global) then end;
end)) then end;
end)

;
((TCP).prototype).write = _func(function (this, buf, cb)
local socket = socket;
socket = (this).socket;
if setImmediate(global, _func(function (this)
if tm__tcp__write(global, socket, buf, buf.length) then end;
if _truthy(cb) then
if cb(global) then end;
end
end))
 then end;
end)

;
((TCP).prototype).close = _func(function (this)
(this).socket = tm__tcp__close(global, this.socket);
if this:emit(("close")) then end;
end)

;
net = _obj({
  ["connect"]=_func(function (this, port, host, callback)
local client = client;
client = _new(TCP, tm__tcp__open(global));
if client:connect(port, host, callback) then end;
if true then return client; end;
end)});
client = net:connect((80), ("74.125.235.20"), _func(function (this)
if console:log(("client connected")) then end;
if client:write(("GET / HTTP/1.1\r\n\r\n")) then end;
end));
if client:on(("data"), _func(function (this, data)
if console:log(String(global, data)) then end;
end)) then end;

return _module.exports;
end
-- client.on('end', function() {
--   console.log('client disconnected');
-- });
