

return function (_ENV)
local string, math, print, type, pairs = nil, nil, nil, nil, nil;
local _module = _obj({exports=_obj({})}); local exports, module = _module.exports, _module;

if ((function (this) 
local async, root, previous____async, only____once, ____each, ____map, ____reduce, ____keys, ____eachLimit, doParallel, doParallelLimit, doSeries, ____asyncMap, ____mapLimit, ____filter, ____reject, ____detect, ____parallel, ____concat, ____console____fn, ____applyEach = async, root, previous____async, only____once, ____each, ____map, ____reduce, ____keys, ____eachLimit, doParallel, doParallelLimit, doSeries, ____asyncMap, ____mapLimit, ____filter, ____reject, ____detect, ____parallel, ____concat, ____console____fn, ____applyEach;
only__once = (function (this, fn) 
local only__once = _debug.getinfo(1, 'f').func;
local called = called;
called = (false);
if true then return (function (this, ...) 
local arguments = _arguments(...);
if _truthy(called) then
_error(_new(Error, ("Callback was already called.")))
end;
called = (true);
if fn:apply(root, arguments) then end; 
end); end;
end);
async = _obj({
  });
root = nil;
previous__async = nil;
root = this;
if (root ~= (null)) then
previous__async = (root).async;
end;
(async).noConflict = (function (this) 
(root).async = previous__async;
if true then return async; end;
end);
__each = (function (this, arr, iterator) 
local i = i;
if _truthy((arr).forEach) then
if true then return arr:forEach(iterator); end;
end;
i = (0);
while (i < (arr).length) do 

if iterator(global, arr[i], i, arr) then end; 

if (function () local _r = i + (1); i = _r; return _r; end)() then end;
end;
end);
__map = (function (this, arr, iterator) 
local results = results;
if _truthy((arr).map) then
if true then return arr:map(iterator); end;
end;
results = _arr({});
if __each(global, arr, (function (this, x, i, a) 
if results:push(iterator(global, x, i, a)) then end; 
end)) then end; 
if true then return results; end;
end);
__reduce = (function (this, arr, iterator, memo) 
if _truthy((arr).reduce) then
if true then return arr:reduce(iterator, memo); end;
end;
if __each(global, arr, (function (this, x, i, a) 
memo = iterator(global, memo, x, i, a);
end)) then end; 
if true then return memo; end;
end);
__keys = (function (this, obj) 
local keys, k = keys, k;
if _truthy((Object).keys) then
if true then return Object:keys(obj); end;
end;
keys = _arr({});
for k in _pairs(obj) do
if _truthy(obj:hasOwnProperty(k)) then
if keys:push(k) then end; 
end;
end;
if true then return keys; end;
end);
if _truthy((_typeof(process) == ("undefined")) or (not _truthy((process).nextTick))) then
if (_typeof(setImmediate) == ("function")) then
(async).nextTick = (function (this, fn) 
if setImmediate(global, fn) then end; 
end);
(async).setImmediate = (async).nextTick;
else 
(async).nextTick = (function (this, fn) 
if setTimeout(global, fn, (0)) then end; 
end);
(async).setImmediate = (async).nextTick;
end;
else 
(async).nextTick = (process).nextTick;
if (_typeof(setImmediate) ~= ("undefined")) then
(async).setImmediate = setImmediate;
else 
(async).setImmediate = (async).nextTick;
end;
end;
(async).each = (function (this, arr, iterator, callback) 
local completed = completed;
callback = callback or (function (this) 

end);
if (not _truthy((arr).length)) then
if true then return callback(global); end;
end;
completed = (0);
if __each(global, arr, (function (this, x) 
if iterator(global, x, only__once(global, (function (this, err) 
if _truthy(err) then
if callback(global, err) then end; 
callback = (function (this) 

end);
else 
completed = completed + (1);
if (completed >= (arr).length) then
if callback(global, (null)) then end; 
end;
end;
end))) then end; 
end)) then end; 
end);
(async).forEach = (async).each;
(async).eachSeries = (function (this, arr, iterator, callback) 
local completed, iterate = completed, iterate;
callback = callback or (function (this) 

end);
if (not _truthy((arr).length)) then
if true then return callback(global); end;
end;
completed = (0);
iterate = (function (this) 
if iterator(global, arr[completed], (function (this, err) 
if _truthy(err) then
if callback(global, err) then end; 
callback = (function (this) 

end);
else 
completed = completed + (1);
if (completed >= (arr).length) then
if callback(global, (null)) then end; 
else 
if iterate(global) then end; 
end;
end;
end)) then end; 
end);
if iterate(global) then end; 
end);
(async).forEachSeries = (async).eachSeries;
(async).eachLimit = (function (this, arr, limit, iterator, callback) 
local fn = fn;
fn = __eachLimit(global, limit);
if fn:apply((null), _arr({[0]=arr, iterator, callback})) then end; 
end);
(async).forEachLimit = (async).eachLimit;
__eachLimit = (function (this, limit) 
if true then return (function (this, arr, iterator, callback) 
local completed, started, running, replenish = completed, started, running, replenish;
callback = callback or (function (this) 

end);
if _truthy((not _truthy((arr).length)) or (limit <= (0))) then
if true then return callback(global); end;
end;
completed = (0);
started = (0);
running = (0);
if (function (this) 
local replenish = _debug.getinfo(1, 'f').func;
if (completed >= (arr).length) then
if true then return callback(global); end;
end;
while _truthy((running < limit) and (started < (arr).length)) do 

started = started + (1);
running = running + (1);
if iterator(global, arr[(started - (1))], (function (this, err) 
if _truthy(err) then
if callback(global, err) then end; 
callback = (function (this) 

end);
else 
completed = completed + (1);
running = running - (1);
if (completed >= (arr).length) then
if callback(global) then end; 
else 
if replenish(global) then end; 
end;
end;
end)) then end; 

end;
end)(global) then end; 
end); end;
end);
doParallel = (function (this, fn) 
if true then return (function (this, ...) 
local arguments = _arguments(...);
local args = args;
args = ((Array).prototype).slice:call(arguments);
if true then return fn:apply((null), _arr({[0]=(async).each}):concat(args)); end;
end); end;
end);
doParallelLimit = (function (this, limit, fn) 
if true then return (function (this, ...) 
local arguments = _arguments(...);
local args = args;
args = ((Array).prototype).slice:call(arguments);
if true then return fn:apply((null), _arr({[0]=__eachLimit(global, limit)}):concat(args)); end;
end); end;
end);
doSeries = (function (this, fn) 
if true then return (function (this, ...) 
local arguments = _arguments(...);
local args = args;
args = ((Array).prototype).slice:call(arguments);
if true then return fn:apply((null), _arr({[0]=(async).eachSeries}):concat(args)); end;
end); end;
end);
__asyncMap = (function (this, eachfn, arr, iterator, callback) 
local results = results;
results = _arr({});
arr = __map(global, arr, (function (this, x, i) 
if true then return _obj({
  ["index"]=i,
  ["value"]=x}); end;
end));
if eachfn(global, arr, (function (this, x, callback) 
if iterator(global, x.value, (function (this, err, v) 
(results)[(x).index] = v;
if callback(global, err) then end; 
end)) then end; 
end), (function (this, err) 
if callback(global, err, results) then end; 
end)) then end; 
end);
(async).map = doParallel(global, __asyncMap);
(async).mapSeries = doSeries(global, __asyncMap);
(async).mapLimit = (function (this, arr, limit, iterator, callback) 
if true then return __mapLimit(global, limit)(global, arr, iterator, callback); end;
end);
__mapLimit = (function (this, limit) 
if true then return doParallelLimit(global, limit, __asyncMap); end;
end);
(async).reduce = (function (this, arr, memo, iterator, callback) 
if async:eachSeries(arr, (function (this, x, callback) 
if iterator(global, memo, x, (function (this, err, v) 
memo = v;
if callback(global, err) then end; 
end)) then end; 
end), (function (this, err) 
if callback(global, err, memo) then end; 
end)) then end; 
end);
(async).inject = (async).reduce;
(async).foldl = (async).reduce;
(async).reduceRight = (function (this, arr, memo, iterator, callback) 
local reversed = reversed;
reversed = __map(global, arr, (function (this, x) 
if true then return x; end;
end)):reverse();
if async:reduce(reversed, memo, iterator, callback) then end; 
end);
(async).foldr = (async).reduceRight;
__filter = (function (this, eachfn, arr, iterator, callback) 
local results = results;
results = _arr({});
arr = __map(global, arr, (function (this, x, i) 
if true then return _obj({
  ["index"]=i,
  ["value"]=x}); end;
end));
if eachfn(global, arr, (function (this, x, callback) 
if iterator(global, x.value, (function (this, v) 
if _truthy(v) then
if results:push(x) then end; 
end;
if callback(global) then end; 
end)) then end; 
end), (function (this, err) 
if callback(global, __map(global, results:sort((function (this, a, b) 
if true then return ((a).index - (b).index); end;
end)), (function (this, x) 
if true then return (x).value; end;
end))) then end; 
end)) then end; 
end);
(async).filter = doParallel(global, __filter);
(async).filterSeries = doSeries(global, __filter);
(async).select = (async).filter;
(async).selectSeries = (async).filterSeries;
__reject = (function (this, eachfn, arr, iterator, callback) 
local results = results;
results = _arr({});
arr = __map(global, arr, (function (this, x, i) 
if true then return _obj({
  ["index"]=i,
  ["value"]=x}); end;
end));
if eachfn(global, arr, (function (this, x, callback) 
if iterator(global, x.value, (function (this, v) 
if (not _truthy(v)) then
if results:push(x) then end; 
end;
if callback(global) then end; 
end)) then end; 
end), (function (this, err) 
if callback(global, __map(global, results:sort((function (this, a, b) 
if true then return ((a).index - (b).index); end;
end)), (function (this, x) 
if true then return (x).value; end;
end))) then end; 
end)) then end; 
end);
(async).reject = doParallel(global, __reject);
(async).rejectSeries = doSeries(global, __reject);
__detect = (function (this, eachfn, arr, iterator, main__callback) 
if eachfn(global, arr, (function (this, x, callback) 
if iterator(global, x, (function (this, result) 
if _truthy(result) then
if main__callback(global, x) then end; 
main__callback = (function (this) 

end);
else 
if callback(global) then end; 
end;
end)) then end; 
end), (function (this, err) 
if main__callback(global) then end; 
end)) then end; 
end);
(async).detect = doParallel(global, __detect);
(async).detectSeries = doSeries(global, __detect);
(async).some = (function (this, arr, iterator, main__callback) 
if async:each(arr, (function (this, x, callback) 
if iterator(global, x, (function (this, v) 
if _truthy(v) then
if main__callback(global, (true)) then end; 
main__callback = (function (this) 

end);
end;
if callback(global) then end; 
end)) then end; 
end), (function (this, err) 
if main__callback(global, (false)) then end; 
end)) then end; 
end);
(async).any = (async).some;
(async).every = (function (this, arr, iterator, main__callback) 
if async:each(arr, (function (this, x, callback) 
if iterator(global, x, (function (this, v) 
if (not _truthy(v)) then
if main__callback(global, (false)) then end; 
main__callback = (function (this) 

end);
end;
if callback(global) then end; 
end)) then end; 
end), (function (this, err) 
if main__callback(global, (true)) then end; 
end)) then end; 
end);
(async).all = (async).every;
(async).sortBy = (function (this, arr, iterator, callback) 
if async:map(arr, (function (this, x, callback) 
if iterator(global, x, (function (this, err, criteria) 
if _truthy(err) then
if callback(global, err) then end; 
else 
if callback(global, (null), _obj({
  ["value"]=x,
  ["criteria"]=criteria})) then end; 
end;
end)) then end; 
end), (function (this, err, results) 
local fn = fn;
if _truthy(err) then
if true then return callback(global, err); end;
else 
fn = (function (this, left, right) 
local a, b = a, b;
a = (left).criteria;
b = (right).criteria;
if true then return ((a < b) and {(-(1))} or {((a > b) and {(1)} or {(0)})[1]})[1]; end;
end);
if callback(global, (null), __map(global, results:sort(fn), (function (this, x) 
if true then return (x).value; end;
end))) then end; 
end;
end)) then end; 
end);
(async).auto = (function (this, tasks, callback) 
local keys, results, listeners, addListener, removeListener, taskComplete = keys, results, listeners, addListener, removeListener, taskComplete;
callback = callback or (function (this) 

end);
keys = __keys(global, tasks);
if (not _truthy((keys).length)) then
if true then return callback(global, (null)); end;
end;
results = _obj({
  });
listeners = _arr({});
addListener = (function (this, fn) 
if listeners:unshift(fn) then end; 
end);
removeListener = (function (this, fn) 
local i = i;
i = (0);
while (i < (listeners).length) do 

if ((listeners)[i] == fn) then
if listeners:splice(i, (1)) then end; 
if true then return; end;
end;

if (function () local _r = i + (1); i = _r; return _r; end)() then end;
end;
end);
taskComplete = (function (this) 
if __each(global, listeners:slice((0)), (function (this, fn) 
if fn(global) then end; 
end)) then end; 
end);
if addListener(global, (function (this) 
if ((__keys(global, results)).length == (keys).length) then
if callback(global, (null), results) then end; 
callback = (function (this) 

end);
end;
end)) then end; 
if __each(global, keys, (function (this, k) 
local task, taskCallback, requires, ready, listener = task, taskCallback, requires, ready, listener;
task = (_instanceof((tasks)[k], Function) and {_arr({[0]=(tasks)[k]})} or {(tasks)[k]})[1];
taskCallback = (function (this, ...) 
local arguments = _arguments(...);
local err = ...;
local args, safeResults = args, safeResults;
args = ((Array).prototype).slice:call(arguments, (1));
if ((args).length <= (1)) then
args = (args)[(0)];
end;
if _truthy(err) then
safeResults = _obj({
  });
if __each(global, __keys(global, results), (function (this, rkey) 
(safeResults)[rkey] = (results)[rkey];
end)) then end; 
(safeResults)[k] = args;
if callback(global, err, safeResults) then end; 
callback = (function (this) 

end);
else 
(results)[k] = args;
if async:setImmediate(taskComplete) then end; 
end;
end);
requires = task:slice((0), Math:abs(((task).length - (1)))) or _arr({});
ready = (function (this) 
if true then return __reduce(global, requires, (function (this, a, x) 
if true then return a and results:hasOwnProperty(x); end;
end), (true)) and (not _truthy(results:hasOwnProperty(k))); end;
end);
if _truthy(ready(global)) then
if (function () local _base, _prop = task, ((task).length - (1)); local _val = _base[_prop]; console:log(_base, _prop, _val); return _val(_base, taskCallback, results); end)() then end; 
else 
listener = (function (this) 
if _truthy(ready(global)) then
if removeListener(global, listener) then end; 
if (function () local _base, _prop = task, ((task).length - (1)); local _val = _base[_prop]; console:log(_base, _prop, _val); return _val(_base, taskCallback, results); end)() then end; 
end;
end);
if addListener(global, listener) then end; 
end;
end)) then end; 
end);
(async).waterfall = (function (this, tasks, callback) 
local err, wrapIterator = err, wrapIterator;
callback = callback or (function (this) 

end);
if ((tasks).constructor ~= Array) then
err = _new(Error, ("First argument to waterfall must be an array of functions"));
if true then return callback(global, err); end;
end;
if (not _truthy((tasks).length)) then
if true then return callback(global); end;
end;
wrapIterator = (function (this, iterator) 
if true then return (function (this, ...) 
local arguments = _arguments(...);
local err = ...;
local args, next = args, next;
if _truthy(err) then
if callback:apply((null), arguments) then end; 
callback = (function (this) 

end);
else 
args = ((Array).prototype).slice:call(arguments, (1));
next = iterator:next();
if _truthy(next) then
if args:push(wrapIterator(global, next)) then end; 
else 
if args:push(callback) then end; 
end;
if async:setImmediate((function (this) 
if iterator:apply((null), args) then end; 
end)) then end; 
end;
end); end;
end);
if wrapIterator(global, async:iterator(tasks))(global) then end; 
end);
__parallel = (function (this, eachfn, tasks, callback) 
local results = results;
callback = callback or (function (this) 

end);
if ((tasks).constructor == Array) then
if eachfn:map(tasks, (function (this, fn, callback) 
if _truthy(fn) then
if fn(global, (function (this, ...) 
local arguments = _arguments(...);
local err = ...;
local args = args;
args = ((Array).prototype).slice:call(arguments, (1));
if ((args).length <= (1)) then
args = (args)[(0)];
end;
if callback:call((null), err, args) then end; 
end)) then end; 
end;
end), callback) then end; 
else 
results = _obj({
  });
if eachfn:each(__keys(global, tasks), (function (this, k, callback) 
if (function () local _base, _prop = tasks, k; local _val = _base[_prop]; console:log(_base, _prop, _val); return _val(_base, (function (this, ...) 
local arguments = _arguments(...);
local err = ...;
local args = args;
args = ((Array).prototype).slice:call(arguments, (1));
if ((args).length <= (1)) then
args = (args)[(0)];
end;
(results)[k] = args;
if callback(global, err) then end; 
end)); end)() then end; 
end), (function (this, err) 
if callback(global, err, results) then end; 
end)) then end; 
end;
end);
(async).parallel = (function (this, tasks, callback) 
if __parallel(global, _obj({
  ["map"]=(async).map,
  ["each"]=(async).each}), tasks, callback) then end; 
end);
(async).parallelLimit = (function (this, tasks, limit, callback) 
if __parallel(global, _obj({
  ["map"]=__mapLimit(global, limit),
  ["each"]=__eachLimit(global, limit)}), tasks, callback) then end; 
end);
(async).series = (function (this, tasks, callback) 
local results = results;
callback = callback or (function (this) 

end);
if ((tasks).constructor == Array) then
if async:mapSeries(tasks, (function (this, fn, callback) 
if _truthy(fn) then
if fn(global, (function (this, ...) 
local arguments = _arguments(...);
local err = ...;
local args = args;
args = ((Array).prototype).slice:call(arguments, (1));
if ((args).length <= (1)) then
args = (args)[(0)];
end;
if callback:call((null), err, args) then end; 
end)) then end; 
end;
end), callback) then end; 
else 
results = _obj({
  });
if async:eachSeries(__keys(global, tasks), (function (this, k, callback) 
if console:log(tasks) then end; 
if (function () local _base, _prop = tasks, k; local _val = _base[_prop]; console:log(_base, _prop, _val); return _val(_base, (function (this, ...) 
local arguments = _arguments(...);
local err = ...;
local args = args;
args = ((Array).prototype).slice:call(arguments, (1));
if ((args).length <= (1)) then
args = (args)[(0)];
end;
(results)[k] = args;
if callback(global, err) then end; 
end)); end)() then end; 
end), (function (this, err) 
if callback(global, err, results) then end; 
end)) then end; 
end;
end);
(async).iterator = (function (this, tasks) 
local makeCallback = makeCallback;
makeCallback = (function (this, index) 
local fn = fn;
fn = (function (this, ...) 
local arguments = _arguments(...);
if _truthy((tasks).length) then
if (tasks)[index]:apply((null), arguments) then end; 
end;
if true then return fn:next(); end;
end);
(fn).next = (function (this) 
if true then return ((index < ((tasks).length - (1))) and {makeCallback(global, (index + (1)))} or {(null)})[1]; end;
end);
if true then return fn; end;
end);
if true then return makeCallback(global, (0)); end;
end);
(async).apply = (function (this, ...) 
local arguments = _arguments(...);
local fn = ...;
local args = args;
args = ((Array).prototype).slice:call(arguments, (1));
if true then return (function (this, ...) 
local arguments = _arguments(...);
if true then return fn:apply((null), args:concat(((Array).prototype).slice:call(arguments))); end;
end); end;
end);
__concat = (function (this, eachfn, arr, fn, callback) 
local r = r;
r = _arr({});
if eachfn(global, arr, (function (this, x, cb) 
if fn(global, x, (function (this, err, y) 
r = r:concat(y or _arr({}));
if cb(global, err) then end; 
end)) then end; 
end), (function (this, err) 
if callback(global, err, r) then end; 
end)) then end; 
end);
(async).concat = doParallel(global, __concat);
(async).concatSeries = doSeries(global, __concat);
(async).whilst = (function (this, test, iterator, callback) 
if _truthy(test(global)) then
if iterator(global, (function (this, err) 
if _truthy(err) then
if true then return callback(global, err); end;
end;
if async:whilst(test, iterator, callback) then end; 
end)) then end; 
else 
if callback(global) then end; 
end;
end);
(async).doWhilst = (function (this, iterator, test, callback) 
if iterator(global, (function (this, err) 
if _truthy(err) then
if true then return callback(global, err); end;
end;
if _truthy(test(global)) then
if async:doWhilst(iterator, test, callback) then end; 
else 
if callback(global) then end; 
end;
end)) then end; 
end);
(async)["until"] = (function (this, test, iterator, callback) 
if (not _truthy(test(global))) then
if iterator(global, (function (this, err) 
if _truthy(err) then
if true then return callback(global, err); end;
end;
if (function () local base, prop = async, "until"; return base[prop](base, test, iterator, callback); end)() then end; 
end)) then end; 
else 
if callback(global) then end; 
end;
end);
(async).doUntil = (function (this, iterator, test, callback) 
if iterator(global, (function (this, err) 
if _truthy(err) then
if true then return callback(global, err); end;
end;
if (not _truthy(test(global))) then
if async:doUntil(iterator, test, callback) then end; 
else 
if callback(global) then end; 
end;
end)) then end; 
end);
(async).queue = (function (this, worker, concurrency) 
local ____insert, workers, q = ____insert, workers, q;
__insert = (function (this, q, data, pos, callback) 
local __insert = _debug.getinfo(1, 'f').func;
if ((data).constructor ~= Array) then
data = _arr({[0]=data});
end;
if __each(global, data, (function (this, task) 
local item = item;
item = _obj({
  ["data"]=task,
  ["callback"]=((_typeof(callback) == ("function")) and {callback} or {(null)})[1]});
if _truthy(pos) then
if (q).tasks:unshift(item) then end; 
else 
if (q).tasks:push(item) then end; 
end;
if _truthy((q).saturated and (((q).tasks).length == concurrency)) then
if q:saturated() then end; 
end;
if async:setImmediate(q.process) then end; 
end)) then end; 
end);
if (concurrency == undefined) then
concurrency = (1);
end;
workers = (0);
q = _obj({
  ["tasks"]=_arr({}),
  ["concurrency"]=concurrency,
  ["saturated"]=null,
  ["empty"]=null,
  ["drain"]=null,
  ["push"]=(function (this, data, callback) 
if __insert(global, q, data, (false), callback) then end; 
end),
  ["unshift"]=(function (this, data, callback) 
if __insert(global, q, data, (true), callback) then end; 
end),
  ["process"]=(function (this) 
local task, next, cb = task, next, cb;
if _truthy((workers < (q).concurrency) and ((q).tasks).length) then
task = (q).tasks:shift();
if _truthy((q).empty and (((q).tasks).length == (0))) then
if q:empty() then end; 
end;
workers = workers + (1);
next = (function (this, ...) 
local arguments = _arguments(...);
workers = workers - (1);
if _truthy((task).callback) then
if (task).callback:apply(task, arguments) then end; 
end;
if _truthy((q).drain and ((((q).tasks).length + workers) == (0))) then
if q:drain() then end; 
end;
if q:process() then end; 
end);
cb = only__once(global, next);
if worker(global, task.data, cb) then end; 
end;
end),
  ["length"]=(function (this) 
if true then return ((q).tasks).length; end;
end),
  ["running"]=(function (this) 
if true then return workers; end;
end)});
if true then return q; end;
end);
(async).cargo = (function (this, worker, payload) 
local working, tasks, process, cargo = working, tasks, process, cargo;
working = (false);
tasks = _arr({});
cargo = _obj({
  ["tasks"]=tasks,
  ["payload"]=payload,
  ["saturated"]=null,
  ["empty"]=null,
  ["drain"]=null,
  ["push"]=(function (this, data, callback) 
if ((data).constructor ~= Array) then
data = _arr({[0]=data});
end;
if __each(global, data, (function (this, task) 
if tasks:push(_obj({
  ["data"]=task,
  ["callback"]=((_typeof(callback) == ("function")) and {callback} or {(null)})[1]})) then end; 
if _truthy((cargo).saturated and ((tasks).length == payload)) then
if cargo:saturated() then end; 
end;
end)) then end; 
if async:setImmediate(cargo.process) then end; 
end),
  ["process"]=(function () process = (function (this) 
local process = _debug.getinfo(1, 'f').func;
local ts, ds = ts, ds;
if _truthy(working) then
if true then return; end;
end;
if ((tasks).length == (0)) then
if _truthy((cargo).drain) then
if cargo:drain() then end; 
end;
if true then return; end;
end;
ts = ((_typeof(payload) == ("number")) and {tasks:splice((0), payload)} or {tasks:splice((0))})[1];
ds = __map(global, ts, (function (this, task) 
if true then return (task).data; end;
end));
if _truthy((cargo).empty) then
if cargo:empty() then end; 
end;
working = (true);
if worker(global, ds, (function (this, ...) 
local arguments = _arguments(...);
local args = args;
working = (false);
args = arguments;
if __each(global, ts, (function (this, data) 
if _truthy((data).callback) then
if (data).callback:apply((null), args) then end; 
end;
end)) then end; 
if process(global) then end; 
end)) then end; 
end); return process; end)(),
  ["length"]=(function (this) 
if true then return (tasks).length; end;
end),
  ["running"]=(function (this) 
if true then return working; end;
end)});
if true then return cargo; end;
end);
__console__fn = (function (this, name) 
if true then return (function (this, ...) 
local arguments = _arguments(...);
local fn = ...;
local args = args;
args = ((Array).prototype).slice:call(arguments, (1));
if fn:apply((null), args:concat(_arr({[0]=(function (this, ...) 
local arguments = _arguments(...);
local err = ...;
local args = args;
args = ((Array).prototype).slice:call(arguments, (1));
if (_typeof(console) ~= ("undefined")) then
if _truthy(err) then
if _truthy((console)["error"]) then
if (function () local base, prop = console, "error"; return base[prop](base, err); end)() then end; 
end;
else 
if _truthy((console)[name]) then
if __each(global, args, (function (this, x) 
if (function () local _base, _prop = console, name; local _val = _base[_prop]; console:log(_base, _prop, _val); return _val(_base, x); end)() then end; 
end)) then end; 
end;
end;
end;
end)}))) then end; 
end); end;
end);
(async).log = __console__fn(global, ("log"));
(async).dir = __console__fn(global, ("dir"));
(async).memoize = (function (this, fn, hasher) 
local memo, queues, memoized = memo, queues, memoized;
memo = _obj({
  });
queues = _obj({
  });
hasher = hasher or (function (this, x) 
if true then return x; end;
end);
memoized = (function (this, ...) 
local arguments = _arguments(...);
local args, callback, key = args, callback, key;
args = ((Array).prototype).slice:call(arguments);
callback = args:pop();
key = hasher:apply((null), args);
if _in(key, memo) then
if callback:apply((null), memo[key]) then end; 
else 
if _in(key, queues) then
if (queues)[key]:push(callback) then end; 
else 
(queues)[key] = _arr({[0]=callback});
if fn:apply((null), args:concat(_arr({[0]=(function (this, ...) 
local arguments = _arguments(...);
local q, i, l = q, i, l;
(memo)[key] = arguments;
q = (queues)[key];
(queues)[key] = nil;
i = (0);
l = (q).length;
while (i < l) do 

if (q)[i]:apply((null), arguments) then end; 

(function () local _r = i; i = _r + 1; return _r end)()
end;
end)}))) then end; 
end;
end;
end);
(memoized).memo = memo;
(memoized).unmemoized = fn;
if true then return memoized; end;
end);
(async).unmemoize = (function (this, fn) 
if true then return (function (this, ...) 
local arguments = _arguments(...);
if true then return (fn).unmemoized or fn:apply((null), arguments); end;
end); end;
end);
(async).times = (function (this, count, iterator, callback) 
local counter, i = counter, i;
counter = _arr({});
i = (0);
while (i < count) do 

if counter:push(i) then end; 

(function () local _r = i; i = _r + 1; return _r end)()
end;
if true then return async:map(counter, iterator, callback); end;
end);
(async).timesSeries = (function (this, count, iterator, callback) 
local counter, i = counter, i;
counter = _arr({});
i = (0);
while (i < count) do 

if counter:push(i) then end; 

(function () local _r = i; i = _r + 1; return _r end)()
end;
if true then return async:mapSeries(counter, iterator, callback); end;
end);
(async).compose = (function (this, ...) 
local arguments = _arguments(...);
local fns = fns;
fns = ((Array).prototype).reverse:call(arguments);
if true then return (function (this, ...) 
local arguments = _arguments(...);
local that, args, callback = that, args, callback;
that = this;
args = ((Array).prototype).slice:call(arguments);
callback = args:pop();
if async:reduce(fns, args, (function (this, newargs, fn, cb) 
if fn:apply(that, newargs:concat(_arr({[0]=(function (this, ...) 
local arguments = _arguments(...);
local err, nextargs = err, nextargs;
err = (arguments)[(0)];
nextargs = ((Array).prototype).slice:call(arguments, (1));
if cb(global, err, nextargs) then end; 
end)})))
             then end; 
end), (function (this, err, results) 
if callback:apply(that, _arr({[0]=err}):concat(results)) then end; 
end)) then end; 
end); end;
end);
__applyEach = (function (this, ...) 
local arguments = _arguments(...);
local eachfn, fns = ...;
local go, args = go, args;
go = (function (this, ...) 
local arguments = _arguments(...);
local that, args, callback = that, args, callback;
that = this;
args = ((Array).prototype).slice:call(arguments);
callback = args:pop();
if true then return eachfn(global, fns, (function (this, fn, cb) 
if fn:apply(that, args:concat(_arr({[0]=cb}))) then end; 
end), callback); end;
end);
if ((arguments).length > (2)) then
args = ((Array).prototype).slice:call(arguments, (2));
if true then return go:apply(this, args); end;
else 
if true then return go; end;
end;
end);
(async).applyEach = doParallel(global, __applyEach);
(async).applyEachSeries = doSeries(global, __applyEach);
(async).forever = (function (this, fn, callback) 
local next = next;
next = (function (this, err) 
local next = _debug.getinfo(1, 'f').func;
if _truthy(err) then
if _truthy(callback) then
if true then return callback(global, err); end;
end;
_error(err)
end;
if fn(global, next) then end; 
end);
if next(global) then end; 
end);
if _truthy((_typeof(define) ~= ("undefined")) and (define).amd) then
if define(global, _arr({}), (function (this) 
if true then return async; end;
end)) then end; 
else 
if _truthy((_typeof(module) ~= ("undefined")) and (module).exports) then
(module).exports = async;
else 
(root).async = async;
end;
end;
end)(global)) then end; 

return _module.exports;
end 

